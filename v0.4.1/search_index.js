var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Only exported names are part of the API.","category":"page"},{"location":"api/#MultiAgentPathFinding","page":"API reference","title":"MultiAgentPathFinding","text":"MultiAgentPathFinding\n\nA package for Multi-Agent Path Finding instances and algorithms.\n\nExports\n\nEdgeConflict\nMAPF\nReservation\nSolution\nTimedPath\nVertexConflict\ncooperative_astar\ndijkstra_by_arrival\ndouble_search\nfeasibility_search\nfind_conflict\nindependent_dijkstra\nis_feasible\nlist_map_names\nlist_scenario_names\nnb_agents\noptimality_search\npath_cost\nread_benchmark\nselect_agents\nsolution_cost\n\n\n\n\n\n","category":"module"},{"location":"api/#Structures","page":"API reference","title":"Structures","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.MAPF","page":"API reference","title":"MultiAgentPathFinding.MAPF","text":"struct MAPF{G<:Graphs.AbstractGraph{Int64}, M, VC, EC}\n\nInstance of a Multi-Agent Path Finding problem with custom conflict rules.\n\nFields\n\ng::Graphs.AbstractGraph{Int64}: underlying graph\nedge_costs::Any: edge costs, typically stored as a matrix\ndepartures::Vector{Int64}: agent departure vertices\narrivals::Vector{Int64}: agent arrival vertices\ndeparture_times::Vector{Int64}: agent departure times\nvertex_conflicts::Any: dict-like object linking vertices to their incompatibility set\nedge_conflicts::Any: dict-like object linking edges (as tuples) to their incompatibility set\n\nNote\n\nAgents appear at their departure vertex when the departure time comes, and they disappear as soon as they have reached the arrival vertex.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.TimedPath","page":"API reference","title":"MultiAgentPathFinding.TimedPath","text":"struct TimedPath\n\nTemporal path through a graph.\n\nFields\n\ntdep::Int64: departure time\npath::Vector{Int64}: sequence of vertices\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Solution","page":"API reference","title":"MultiAgentPathFinding.Solution","text":"struct Solution\n\nStore one TimedPath for each agent of a MAPF.\n\nFields\n\ntimed_paths::Dict{Int64, TimedPath}\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Reservation","page":"API reference","title":"MultiAgentPathFinding.Reservation","text":"struct Reservation\n\nKeep track of which vertices and edges are known to be occupied and by whom.\n\nIt does not have to be a physical occupation: some agent might be occupying a related vertex or edge which generates a conflict.\n\nFields\n\nsingle_occupied_vertices::Dict{Tuple{Int64, Int64}, Int64}: (t, v) -> a where a is the only agent occupying v at time t\nsingle_occupied_edges::Dict{Tuple{Int64, Int64, Int64}, Int64}: (t, u, v) -> a where a is the only agent occupying (u, v) at time t\nmulti_occupied_vertices::Dict{Tuple{Int64, Int64}, Vector{Int64}}: (t, v) -> [a1, a2] where a1, a2 are the multiple agents occupying v at time t\nmulti_occupied_edges::Dict{Tuple{Int64, Int64, Int64}, Vector{Int64}}: (t, u, v) -> [a1, a2] where a1, a2 are the multiple agents occupying (u, v) at time t\n\nNote\n\nThe split between single and multi is done for efficiency reasons: there will be many more single_occupied than multi_occupied, so allocating a set for all of these would be wasteful (and using Union{Int, Set{Int}} would be type-unstable).\n\n\n\n\n\n","category":"type"},{"location":"api/#Access","page":"API reference","title":"Access","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.nb_agents","page":"API reference","title":"MultiAgentPathFinding.nb_agents","text":"nb_agents(mapf::MAPF) -> Int64\n\n\nCount the number of agents in mapf.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.select_agents","page":"API reference","title":"MultiAgentPathFinding.select_agents","text":"select_agents(\n    mapf::MAPF,\n    agents::AbstractVector{<:Integer}\n) -> MAPF\n\n\nSelect a subset of agents in mapf and return a new MAPF.\n\n\n\n\n\n","category":"function"},{"location":"api/#Feasibility-and-cost","page":"API reference","title":"Feasibility and cost","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.path_cost","page":"API reference","title":"MultiAgentPathFinding.path_cost","text":"path_cost(\n    timed_path::TimedPath,\n    a::Integer,\n    mapf::MAPF\n) -> Any\n\n\nSum the costs of all the edges in timed_path. Costs are computed within mapf for agent a.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.solution_cost","page":"API reference","title":"MultiAgentPathFinding.solution_cost","text":"solution_cost(solution::Solution, mapf::MAPF) -> Any\n\n\nSum the costs of all the paths in solution. Costs are computed within mapf for each agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.is_feasible","page":"API reference","title":"MultiAgentPathFinding.is_feasible","text":"is_feasible(solution::Solution, mapf::MAPF; verbose) -> Bool\n\n\nCheck whether solution is both individually and collectively feasible (correct paths and no conflicts).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.find_conflict","page":"API reference","title":"MultiAgentPathFinding.find_conflict","text":"find_conflict(\n    solution::Solution,\n    mapf::MAPF\n) -> Union{Nothing, EdgeConflict, VertexConflict}\n\n\nFind a conflict in solution for mapf.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.VertexConflict","page":"API reference","title":"MultiAgentPathFinding.VertexConflict","text":"struct VertexConflict\n\nTemporal vertex conflict between two agents (for debugging purposes).\n\nFields\n\nt::Int64: time\nv::Int64: vertex\na1::Int64: first agent\na2::Int64: second agent\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.EdgeConflict","page":"API reference","title":"MultiAgentPathFinding.EdgeConflict","text":"struct EdgeConflict\n\nTemporal edge conflict between two agents (for debugging purposes).\n\nFields\n\nt::Int64: time\nu::Int64: edge source\nv::Int64: edge destination\na1::Int64: first agent\na2::Int64: second agent\n\n\n\n\n\n","category":"type"},{"location":"api/#Basic-algorithms","page":"API reference","title":"Basic algorithms","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.dijkstra_by_arrival","page":"API reference","title":"MultiAgentPathFinding.dijkstra_by_arrival","text":"dijkstra_by_arrival(\n    mapf::MAPF;\n    show_progress,\n    threaded\n) -> Dict{Int64, V} where V<:(MultiAgentPathFinding.ShortestPathTree{Int64})\n\n\nRun backward_dijkstra from each arrival vertex of mapf.\n\nReturns a dictionary of ShortestPathTree, one by arrival vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.independent_dijkstra","page":"API reference","title":"MultiAgentPathFinding.independent_dijkstra","text":"independent_dijkstra(\n    mapf::MAPF;\n    show_progress,\n    threaded,\n    spt_by_arr\n) -> Solution\n\n\nCompute independent shortest paths for each agent of mapf.\n\nReturns a Solution where some paths may be empty if the vertices are not connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.cooperative_astar","page":"API reference","title":"MultiAgentPathFinding.cooperative_astar","text":"cooperative_astar(mapf::MAPF; ...) -> Solution\ncooperative_astar(\n    mapf::MAPF,\n    agents::AbstractVector{<:Integer};\n    show_progress,\n    threaded,\n    spt_by_arr\n) -> Solution\n\n\nSolve a MAPF problem mapf for a set of agents with the cooperative A* algorithm of Silver (2005), see https://ojs.aaai.org/index.php/AIIDE/article/view/18726. The A* heuristic is given by independent_dijkstra.\n\nReturns a Solution where some paths may be empty if the vertices are not connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Local-search","page":"API reference","title":"Local search","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.feasibility_search","page":"API reference","title":"MultiAgentPathFinding.feasibility_search","text":"feasibility_search(\n    mapf::MAPF;\n    feasibility_timeout,\n    neighborhood_size,\n    conflict_price,\n    conflict_price_increase,\n    show_progress,\n    threaded,\n    spt_by_arr\n) -> Tuple{Solution, Dict}\n\n\nRun independent_dijkstra and then reduce the number of conflicts with a variant of the MAPF-LNS2 algorithm from Li et al. (2022), see https://ojs.aaai.org/index.php/AAAI/article/view/21266.\n\nReturns a tuple containing a Solution and a dictionary of statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.optimality_search","page":"API reference","title":"MultiAgentPathFinding.optimality_search","text":"optimality_search(mapf::MAPF; ...) -> Tuple{Solution, Dict}\noptimality_search(\n    mapf::MAPF,\n    agents;\n    optimality_timeout,\n    neighborhood_size,\n    show_progress,\n    threaded,\n    spt_by_arr\n) -> Tuple{Solution, Dict}\n\n\nRun cooperative_astar on mapf and then reduce the total path cost with the MAPF-LNS algorithm from Li et al. (2021), see https://www.ijcai.org/proceedings/2021/568.\n\nReturns a tuple containing a Solution and a dictionary of statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.double_search","page":"API reference","title":"MultiAgentPathFinding.double_search","text":"double_search(mapf::MAPF; ...) -> Tuple{Solution, Dict}\ndouble_search(\n    mapf::MAPF,\n    agents;\n    feasibility_timeout,\n    optimality_timeout,\n    neighborhood_size,\n    conflict_price,\n    conflict_price_increase,\n    show_progress,\n    threaded,\n    spt_by_arr\n) -> Tuple{Solution, Dict}\n\n\nCombine feasibility_search and optimality_search, see https://pastel.hal.science/tel-04053322.\n\nReturns a tuple containing a Solution and a dictionary of statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#Benchmarks","page":"API reference","title":"Benchmarks","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.read_benchmark","page":"API reference","title":"MultiAgentPathFinding.read_benchmark","text":"read_benchmark(\n    map_name::AbstractString,\n    scenario_name::AbstractString;\n    check\n) -> MAPF{SimpleWeightedGraphs.SimpleWeightedGraph{Int64, Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, MultiAgentPathFinding.LazyVertexConflicts, MultiAgentPathFinding.LazySwappingConflicts}\n\n\nCreate a MAPF instance by reading a map (\"something.map\") and scenario (\"something.scen\") from files.\n\nSee possible names at https://movingai.com/benchmarks/mapf/index.html (data will be downloaded automatically).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.list_map_names","page":"API reference","title":"MultiAgentPathFinding.list_map_names","text":"list_map_names() -> Vector{String}\n\n\nList available maps from the benchmark set.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.list_scenario_names","page":"API reference","title":"MultiAgentPathFinding.list_scenario_names","text":"list_scenario_names() -> Vector{String}\n\n\nList available scenarios from the benchmark set.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.LazyEdgeConflicts","page":"API reference","title":"MultiAgentPathFinding.LazyEdgeConflicts","text":"struct LazyEdgeConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(u, v)].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazySwappingConflicts","page":"API reference","title":"MultiAgentPathFinding.LazySwappingConflicts","text":"struct LazySwappingConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(v, u)].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazyVertexConflicts","page":"API reference","title":"MultiAgentPathFinding.LazyVertexConflicts","text":"struct LazyVertexConflicts\n\nLazy dict-like storage for the mapping v -> [v].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.MAPFBenchmarkProblem","page":"API reference","title":"MultiAgentPathFinding.MAPFBenchmarkProblem","text":"struct MAPFBenchmarkProblem\n\nEncode one agent of a MAPF scenario.\n\nFields\n\nindex::Int64\nbucket::Int64\nmap_path::String\nwidth::Int64\nheight::Int64\nstart_i::Int64\nstart_j::Int64\ngoal_i::Int64\ngoal_j::Int64\noptimal_length::Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.ShortestPathTree","page":"API reference","title":"MultiAgentPathFinding.ShortestPathTree","text":"struct ShortestPathTree{V, W}\n\nStorage for the result of Dijkstra's algorithm run backwards.\n\nFields\n\nchildren::Vector: successor of each vertex in a shortest path\ndists::Vector: distance of each vertex to the arrival\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.arrival_time-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.arrival_time","text":"arrival_time(timed_path::TimedPath) -> Int64\n\n\nReturn the departure time of timed_path plus its number of edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.arrival_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.arrival_vertex","text":"arrival_vertex(timed_path::TimedPath) -> Int64\n\n\nReturn the last vertex of timed_path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.backward_dijkstra-Tuple{Graphs.AbstractGraph, Any}","page":"API reference","title":"MultiAgentPathFinding.backward_dijkstra","text":"backward_dijkstra(g::Graphs.AbstractGraph, edge_costs; arr)\n\n\nRun Dijkstra's algorithm backward on graph g from arrival vertex arr, with specified edge_costs.\n\nReturns a ShortestPathTree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.benchmark_cell_color-Tuple{Char}","page":"API reference","title":"MultiAgentPathFinding.benchmark_cell_color","text":"benchmark_cell_color(\n    c::Char\n) -> ColorTypes.RGB{FixedPointNumbers.N0f8}\n\n\nGive a color object corresponding to the type of cell.\n\nTo visualize a map in VSCode, just run cell_color.(map_matrix) in the REPL.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_path_astar-Tuple{Dict, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.build_path_astar","text":"build_path_astar(\n    parents::Dict,\n    arr::Integer,\n    tarr::Integer\n) -> TimedPath\n\n\nBuild a TimedPath from a dictionary of temporal parents, going backward from arr which was reached at tarr.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_path_from_tree-Union{Tuple{V}, Tuple{MultiAgentPathFinding.ShortestPathTree{V}, Integer, Integer, Integer}} where V","page":"API reference","title":"MultiAgentPathFinding.build_path_from_tree","text":"build_path_from_tree(\n    spt::MultiAgentPathFinding.ShortestPathTree{V},\n    dep::Integer,\n    arr::Integer,\n    tdep::Integer\n) -> TimedPath\n\n\nBuild a TimedPath from a ShortestPathTree, going from dep to arr and starting at time tdep.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_conflicts-Tuple{Solution, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_conflicts","text":"count_conflicts(solution::Solution, mapf::MAPF) -> Int64\n\n\nCount the number of conflicts in solution for mapf.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.departure_time-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.departure_time","text":"departure_time(timed_path::TimedPath) -> Int64\n\n\nReturn the departure time of timed_path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.departure_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.departure_vertex","text":"departure_vertex(timed_path::TimedPath) -> Int64\n\n\nReturn the first vertex of timed_path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.edge_at_time-Tuple{TimedPath, Integer}","page":"API reference","title":"MultiAgentPathFinding.edge_at_time","text":"edge_at_time(\n    timed_path::TimedPath,\n    t::Integer\n) -> Tuple{Any, Any}\n\n\nReturn the edge crossed by timed_path at a given time t, throws an error if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.edge_cost-Tuple{AbstractMatrix, Integer, Integer, Vararg{Any}}","page":"API reference","title":"MultiAgentPathFinding.edge_cost","text":"edge_cost(edge_costs::AbstractMatrix, u, v)\nedge_cost(edge_costs::AbstractMatrix, u, v, a, t)\n\nReturn the cost of edge (u, v) for agent a at time t when the cost storage edge_costs is a matrix (hence agent- and time-independent).\n\nThis method, as well as Base.eltype, must be overridden for other storage formats.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.exists_in_graph-Tuple{TimedPath, Graphs.AbstractGraph}","page":"API reference","title":"MultiAgentPathFinding.exists_in_graph","text":"exists_in_graph(\n    timed_path::TimedPath,\n    g::Graphs.AbstractGraph\n) -> Bool\n\n\nCheck that timed_path is feasible in the graph g, i.e. that all vertices and edges exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_collectively_feasible-Tuple{Solution, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_collectively_feasible","text":"is_collectively_feasible(\n    solution::Solution,\n    mapf::MAPF;\n    verbose\n) -> Bool\n\n\nCheck whether solution contains any conflicts between agents.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_individually_feasible-Tuple{Solution, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_individually_feasible","text":"is_individually_feasible(\n    solution::Solution,\n    mapf::MAPF;\n    verbose\n) -> Bool\n\n\nCheck whether solution is feasible when agents are considered separately.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_occupied_edge-Tuple{Reservation, Integer, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.is_occupied_edge","text":"is_occupied_edge(\n    reservation::Reservation,\n    t::Integer,\n    u::Integer,\n    v::Integer\n) -> Bool\n\n\nCheck whether edge (u, v) is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_occupied_vertex-Tuple{Reservation, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.is_occupied_vertex","text":"is_occupied_vertex(\n    reservation::Reservation,\n    t::Integer,\n    v::Integer\n) -> Bool\n\n\nCheck whether vertex v is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.map_from_scenario-Tuple{AbstractString}","page":"API reference","title":"MultiAgentPathFinding.map_from_scenario","text":"map_from_scenario(scenario_name::AbstractString) -> String\n\n\nReturn the map associated with a benchmark scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.occupy!-Tuple{Reservation, Integer, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.occupy!","text":"occupy!(\n    reservation::Reservation,\n    a::Integer,\n    t::Integer,\n    v::Integer\n)\n\n\nUpdate reservation so that agent a occupies vertex v at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.occupy!-Tuple{Reservation, Vararg{Integer, 4}}","page":"API reference","title":"MultiAgentPathFinding.occupy!","text":"occupy!(\n    reservation::Reservation,\n    a::Integer,\n    t::Integer,\n    u::Integer,\n    v::Integer\n)\n\n\nUpdate reservation so that agent a occupies edge (u, v) at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.parse_benchmark_map-Tuple{Matrix{Char}}","page":"API reference","title":"MultiAgentPathFinding.parse_benchmark_map","text":"parse_benchmark_map(\n    map_matrix::Matrix{Char}\n) -> Tuple{SimpleWeightedGraphs.SimpleWeightedGraph{Int64, Float64}, Dict{Tuple{Int64, Int64}, Int64}}\n\n\nCreate a sparse grid graph from a map specified as a matrix of characters.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.parse_benchmark_scenario-Tuple{Vector{MultiAgentPathFinding.MAPFBenchmarkProblem}, Dict}","page":"API reference","title":"MultiAgentPathFinding.parse_benchmark_scenario","text":"parse_benchmark_scenario(\n    scenario::Vector{MultiAgentPathFinding.MAPFBenchmarkProblem},\n    coord_to_vertex::Dict\n) -> Tuple{Vector{Int64}, Vector{Int64}}\n\n\nTurn a scenario into vectors of departure and arrival vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.random_neighborhood-Tuple{MAPF, Integer}","page":"API reference","title":"MultiAgentPathFinding.random_neighborhood","text":"random_neighborhood(\n    mapf::MAPF,\n    neighborhood_size::Integer\n) -> AbstractArray\n\n\nReturn a random subset of agents with a given size.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.read_benchmark_map-Tuple{AbstractString}","page":"API reference","title":"MultiAgentPathFinding.read_benchmark_map","text":"read_benchmark_map(map_name::AbstractString) -> Matrix{Char}\n\n\nRead a map matrix from a text file.\n\nReturns a Matrix{Char}.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.read_benchmark_scenario-Tuple{AbstractString, AbstractString}","page":"API reference","title":"MultiAgentPathFinding.read_benchmark_scenario","text":"read_benchmark_scenario(\n    scenario_name::AbstractString,\n    map_name::AbstractString\n) -> Vector{MultiAgentPathFinding.MAPFBenchmarkProblem}\n\n\nRead a scenario from a text file, and check that it corresponds to a given map.\n\nReturns a Vector{MAPFBenchmarkProblem}.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.reinsert_agents!-Tuple{Solution, Solution}","page":"API reference","title":"MultiAgentPathFinding.reinsert_agents!","text":"reinsert_agents!(\n    solution::Solution,\n    backup_solution::Solution\n) -> Solution\n\n\nReinsert the set of agents from backup_solution into solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.remove_agents!-Tuple{Solution, AbstractVector{<:Integer}}","page":"API reference","title":"MultiAgentPathFinding.remove_agents!","text":"remove_agents!(\n    solution::Solution,\n    agents::AbstractVector{<:Integer}\n) -> Solution\n\n\nRemove a set of agents from solution and return a backup_solution containing only them.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.scenarios_from_map-Tuple{AbstractString}","page":"API reference","title":"MultiAgentPathFinding.scenarios_from_map","text":"scenarios_from_map(\n    map_name::AbstractString\n) -> Vector{String}\n\n\nList the scenarios associated with a benchmark map.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar-Tuple{MultiAgentPathFinding.HardConflicts, Graphs.AbstractGraph, Any}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar","text":"temporal_astar(\n    ::MultiAgentPathFinding.HardConflicts,\n    g::Graphs.AbstractGraph,\n    edge_costs;\n    a,\n    dep,\n    arr,\n    tdep,\n    reservation,\n    heuristic,\n    max_nodes\n)\n\n\nApply temporal A* to graph g, with specified edge costs.\n\nKeyword arguments\n\na: agent\ndep: departure vertex\narr: arrival vertex\ntdep: departure time\nreservation: reservation indicating occupied vertices and edges at various times\nheuristic: indexable giving an underestimate of the remaining distance to arr\nmax_nodes: maximum number of nodes in the search tree, defaults to nv(g)^3\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar-Tuple{MultiAgentPathFinding.SoftConflicts, Graphs.AbstractGraph, Any}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar","text":"temporal_astar(\n    ::MultiAgentPathFinding.SoftConflicts,\n    g::Graphs.AbstractGraph,\n    edge_costs;\n    a,\n    dep,\n    arr,\n    tdep,\n    reservation,\n    heuristic,\n    conflict_price,\n    max_nodes\n)\n\n\nApply a bi-objective variant of temporal A* to graph g with specified edge_costs.\n\nThe objective is to minimize a weighted combination of (1) the number of conflicts and (2) the path cost.\n\nKeyword arguments\n\na, dep, arr, tdep, reservation, heuristic, max_nodes: see temporal_astar.\nconflict_price: price given to the number of conflicts in the objective\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.update_reservation!-Tuple{Reservation, TimedPath, Integer, MAPF}","page":"API reference","title":"MultiAgentPathFinding.update_reservation!","text":"update_reservation!(\n    reservation::Reservation,\n    timed_path::TimedPath,\n    a::Integer,\n    mapf::MAPF\n)\n\n\nAdd the vertices and edges occupied by a timed path to a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.vertex_at_time-Tuple{TimedPath, Integer}","page":"API reference","title":"MultiAgentPathFinding.vertex_at_time","text":"vertex_at_time(timed_path::TimedPath, t::Integer) -> Any\n\n\nReturn the vertex visited by timed_path at a given time t, throws an error if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"#MultiAgentPathFinding","page":"Home","title":"MultiAgentPathFinding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides a toolbox for defining and solving Multi-Agent PathFinding problems in the Julia programming language.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the latest stable version, open a Julia Pkg REPL and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MultiAgentPathFinding","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the development version, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gdalle/MultiAgentPathFinding.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"For now the documentation is a bit lacking, but take a look at the files in test for usage examples.","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiAgentPathFinding.jl contains some heuristic algorithms (cooperative A* and local search) described in the PhD thesis","category":"page"},{"location":"","page":"Home","title":"Home","text":"Machine learning and combinatorial optimization algorithms, with applications to railway planning, Dalle (2022)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It also contains a parser for the set of benchmark instances introduced by","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multi-Agent Pathfinding: Definitions, Variants, and Benchmarks, Stern et al. (2019)","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Alternative solvers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Shushman/MultiAgentPathFinding.jl: conflict-based search","category":"page"}]
}
