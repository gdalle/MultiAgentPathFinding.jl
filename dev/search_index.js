var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"These symbols are part of the public API, their existence and behavior is guaranteed until the next breaking release.","category":"page"},{"location":"api/#Structures","page":"API reference","title":"Structures","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.MAPF","page":"API reference","title":"MultiAgentPathFinding.MAPF","text":"struct MAPF{W, VC, EC}\n\nInstance of a Multi-Agent Path Finding problem with custom conflict rules.\n\nConstructors\n\nMAPF(\n    graph::AbstractGraph,\n    departures::Vector{Int},\n    arrivals::Vector{Int};\n    vertex_conflicts=LazyVertexConflicts(),\n    edge_conflicts=LazyEdgeConflicts()\n)\n\nFields\n\ngraph::SimpleWeightedGraphs.SimpleWeightedGraph{Int64, W} where W: underlying weighted graph\ndepartures::Vector{Int64}: agent departure vertices\narrivals::Vector{Int64}: agent arrival vertices\nvertex_conflicts::Any: indexable object linking vertices to their incompatibility set\nedge_conflicts::Any: indexable object linking edges (as tuples) to their incompatibility set\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Solution","page":"API reference","title":"MultiAgentPathFinding.Solution","text":"struct Solution\n\nStore one path for each agent of a MAPF.\n\nFields\n\npaths::Vector{Vector{Int64}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Access","page":"API reference","title":"Access","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.nb_agents","page":"API reference","title":"MultiAgentPathFinding.nb_agents","text":"nb_agents(mapf::MAPF) -> Int64\n\n\nCount the number of agents in mapf.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.select_agents","page":"API reference","title":"MultiAgentPathFinding.select_agents","text":"select_agents(\n    mapf::MAPF,\n    agents::AbstractVector{<:Integer}\n) -> MAPF\n\n\nSelect a subset of agents in mapf and return a new MAPF.\n\n\n\n\n\n","category":"function"},{"location":"api/#Feasibility-and-cost","page":"API reference","title":"Feasibility and cost","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.sum_of_costs","page":"API reference","title":"MultiAgentPathFinding.sum_of_costs","text":"sum_of_costs(solution::Solution, mapf::MAPF) -> Any\n\n\nSum the costs of all the paths in solution. Costs are computed within mapf for each agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.is_feasible","page":"API reference","title":"MultiAgentPathFinding.is_feasible","text":"is_feasible(solution::Solution, mapf::MAPF; verbose) -> Bool\n\n\nCheck whether solution is both individually and collectively feasible (correct paths and no conflicts).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.find_conflict","page":"API reference","title":"MultiAgentPathFinding.find_conflict","text":"find_conflict(\n    solution::Solution,\n    mapf::MAPF\n) -> Union{Nothing, EdgeConflict, VertexConflict}\n\n\nFind a conflict in solution for mapf.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.VertexConflict","page":"API reference","title":"MultiAgentPathFinding.VertexConflict","text":"struct VertexConflict\n\nTemporal vertex conflict between two agents (for debugging purposes).\n\nFields\n\nt::Int64: time\nv::Int64: vertex\na1::Int64: first agent\na2::Int64: second agent\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.EdgeConflict","page":"API reference","title":"MultiAgentPathFinding.EdgeConflict","text":"struct EdgeConflict\n\nTemporal edge conflict between two agents (for debugging purposes).\n\nFields\n\nt::Int64: time\nu::Int64: edge source\nv::Int64: edge destination\na1::Int64: first agent\na2::Int64: second agent\n\n\n\n\n\n","category":"type"},{"location":"api/#Basic-algorithms","page":"API reference","title":"Basic algorithms","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.independent_dijkstra","page":"API reference","title":"MultiAgentPathFinding.independent_dijkstra","text":"independent_dijkstra(mapf::MAPF) -> Solution\n\n\nCompute independent shortest paths for each agent of mapf.\n\nReturns a Solution where some paths may be empty if the vertices are not connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.cooperative_astar","page":"API reference","title":"MultiAgentPathFinding.cooperative_astar","text":"cooperative_astar(mapf::MAPF) -> Solution\ncooperative_astar(\n    mapf::MAPF,\n    agents::AbstractVector{<:Integer}\n) -> Solution\n\n\nSolve a MAPF problem mapf for a set of agents with the cooperative A* algorithm of Silver (2005), see https://ojs.aaai.org/index.php/AIIDE/article/view/18726.\n\nReturns a Solution where some paths may be empty if the vertices are not connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Benchmarks","page":"API reference","title":"Benchmarks","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.list_instances","page":"API reference","title":"MultiAgentPathFinding.list_instances","text":"list_instances() -> Vector{SubString{String}}\n\n\nList available maps from the benchmark set.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.BenchmarkScenario","page":"API reference","title":"MultiAgentPathFinding.BenchmarkScenario","text":"BenchmarkScenario\n\nIdentify a specific benchmark map and scenario from the Sturtevant MAPF benchmarks.\n\nFields\n\ninstance::String: name of the instance\nscen_type::String: type of scenario, random or even\ntype_id::Int64: id of the scenario among those with the same type\nagents::Union{Nothing, Int64}: number of agents included\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.read_benchmark_map","page":"API reference","title":"MultiAgentPathFinding.read_benchmark_map","text":"read_benchmark_map(\n    instance_name::AbstractString\n) -> Matrix{Char}\n\n\nRead a map from an automatically downloaded text file.\n\nReturn a Matrix{Char}.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.parse_benchmark_map","page":"API reference","title":"MultiAgentPathFinding.parse_benchmark_map","text":"parse_benchmark_map(\n    grid::AbstractMatrix;\n    allow_diagonal_moves\n) -> @NamedTuple{graph::SimpleWeightedGraphs.SimpleWeightedGraph{Int64, Float64}, coord_to_vertex::Dict{Tuple{Int64, Int64}, Int64}, vertex_to_coord::Vector{Tuple{Int64, Int64}}}\n\n\nCreate a sparse grid graph from a map specified as a matrix of characters.\n\nReturn a named tuple (; graph, coord_to_vertex, vertex_to_coord), where the last two items map between integer graph vertices v and coordinate tuples (i, j).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.passable_cell","page":"API reference","title":"MultiAgentPathFinding.passable_cell","text":"passable_cell(c::Char)\n\nDetermine if a cell is passable terrain or not.\n\n\n\n\n\n","category":"function"},{"location":"api/#Visualization","page":"API reference","title":"Visualization","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.plot_mapf","page":"API reference","title":"MultiAgentPathFinding.plot_mapf","text":"plot_mapf(scen::BenchmarkScenario; ...) -> Makie.Figure\nplot_mapf(\n    scen::BenchmarkScenario,\n    solution::Union{Nothing, Solution};\n    time,\n    video_path,\n    frames_per_move,\n    frames_per_second,\n    display_grid,\n    display_targets\n) -> Makie.Figure\n\n\nVisualize a solution for one of the grid benchmark instances at a given time step.\n\nIf a solution and video_path are provided, the entire animation will be recorded and saved there.\n\nwarning: Warning\nTo use this function, first load a Makie.jl backend, like CairoMakie.jl (for static visualization / animation recording) or GLMakie.jl (for interactive exploration).\n\n\n\n\n\n","category":"function"},{"location":"#MultiAgentPathFinding","page":"Home","title":"MultiAgentPathFinding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides a toolbox for defining and solving multi-agent pathfinding problems in the Julia programming language.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the latest stable version, open a Julia Pkg REPL and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MultiAgentPathFinding","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the development version, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gdalle/MultiAgentPathFinding.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"For now the documentation is a bit lacking, but take a look at the files in test for usage examples.","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiAgentPathFinding.jl contains basic optimization algorithms related to multi-agent pathfinding, as well as a parser for the standard benchmark instances and solutions described in","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multi-Agent Pathfinding: Definitions, Variants, and Benchmarks, Stern et al. (2019)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tracking Progress in Multi-Agent Path Finding, Shen et al. (2023)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use this package, please cite the following PhD dissertation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Machine learning and combinatorial optimization algorithms, with applications to railway planning, Dalle (2022)","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Alternative solvers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Shushman/MultiAgentPathFinding.jl: conflict-based search","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"These symbols are not part of the public API, their existence or behavior can change without a breaking release.","category":"page"},{"location":"internals/#MultiAgentPathFinding.BenchmarkAgent","page":"Internals","title":"MultiAgentPathFinding.BenchmarkAgent","text":"struct BenchmarkAgent\n\nEncode one agent of a MAPF scenario.\n\nFields\n\nagent::Int64\nbucket::Int64\nwidth::Int64\nheight::Int64\nstart_i::Int64\nstart_j::Int64\ngoal_i::Int64\ngoal_j::Int64\noptimal_length::Float64\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultiAgentPathFinding.LazySwappingConflicts","page":"Internals","title":"MultiAgentPathFinding.LazySwappingConflicts","text":"struct LazySwappingConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(u, v),] (which also forbids (v, u) since the graph is undirected).\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultiAgentPathFinding.LazyVertexConflicts","page":"Internals","title":"MultiAgentPathFinding.LazyVertexConflicts","text":"struct LazyVertexConflicts\n\nLazy dict-like storage for the mapping v -> [v].\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultiAgentPathFinding.Reservation","page":"Internals","title":"MultiAgentPathFinding.Reservation","text":"struct Reservation\n\nKeep track of which vertices and edges are known to be occupied and by which agent.\n\nIt does not have to be a physical occupation: some agent might be occupying a related vertex or edge which generates a conflict according to the rules of a MAPF.\n\nEach undirected edge (u, v) is represented as (min(u, v), max(u, v)) in the dictionary keys.\n\nFields\n\nmax_time::Base.RefValue{Int64}: the maximum time of an occupation inside\nsingle_occupied_vertices::Dict{Tuple{Int64, Int64}, Int64}: (t, v) -> a where a is the only agent occupying v at time t\nsingle_occupied_edges::Dict{Tuple{Int64, Int64, Int64}, Int64}: (t, u, v) -> a where a is the only agent occupying (u, v) at time t\nmulti_occupied_vertices::Dict{Tuple{Int64, Int64}, Vector{Int64}}: (t, v) -> [a1, a2] where a1, a2 are the multiple agents occupying v at time t\nmulti_occupied_edges::Dict{Tuple{Int64, Int64, Int64}, Vector{Int64}}: (t, u, v) -> [a1, a2] where a1, a2 are the multiple agents occupying (u, v) at time t\narrival_vertices::Dict{Int64, Tuple{Int64, Int64}}: v -> (t, a) where a is the agent whose arrival vertex is v and who owns it starting at time t (necessary for stay-at-target behavior)\narrival_vertices_crossings::Dict{Int64, Vector{Tuple{Int64, Int64}}}: v -> [(t2, a1), (t2, a2)] where the ai are additional agents visiting vertex v at times ti, once it is already owned as an arrival vertex\n\nNote\n\nThe split between single and multi is done for efficiency reasons: there will be many more single_occupied than multi_occupied, so allocating a set for all of these would be wasteful (and using Union{Int, Set{Int}} would be type-unstable). The same goes for arrival crossings.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultiAgentPathFinding.Reservation-Tuple{Solution, MAPF}","page":"Internals","title":"MultiAgentPathFinding.Reservation","text":"Reservation(\n    solution::Solution,\n    mapf::MAPF\n) -> MultiAgentPathFinding.Reservation\n\n\nCompute a Reservation based on the vertices and edges occupied by solution.\n\nConflicts are computed within mapf.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.Reservation-Tuple{}","page":"Internals","title":"MultiAgentPathFinding.Reservation","text":"Reservation() -> MultiAgentPathFinding.Reservation\n\n\nCreate an empty Reservation.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.arrive!-Tuple{MultiAgentPathFinding.Reservation, Integer, Integer, Integer}","page":"Internals","title":"MultiAgentPathFinding.arrive!","text":"arrive!(\n    reservation::MultiAgentPathFinding.Reservation,\n    a::Integer,\n    t::Integer,\n    v::Integer\n)\n\n\nUpdate reservation so that agent a arrives vertex v at time t and never moves again.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.cell_color-Tuple{Char}","page":"Internals","title":"MultiAgentPathFinding.cell_color","text":"cell_color(\n    c::Char\n) -> ColorTypes.RGB{FixedPointNumbers.N0f8}\n\n\nGive a color object corresponding to the type of cell.\n\nTo visualize a map in VSCode, just run cell_color.(grid) in the REPL.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.exists_in_graph-Tuple{Vector{Int64}, SimpleWeightedGraphs.SimpleWeightedGraph}","page":"Internals","title":"MultiAgentPathFinding.exists_in_graph","text":"exists_in_graph(\n    path::Vector{Int64},\n    g::SimpleWeightedGraphs.SimpleWeightedGraph\n) -> Bool\n\n\nCheck that path is feasible in the graph g, i.e. that all vertices and edges exist.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.is_collectively_feasible-Tuple{Solution, MAPF}","page":"Internals","title":"MultiAgentPathFinding.is_collectively_feasible","text":"is_collectively_feasible(\n    solution::Solution,\n    mapf::MAPF;\n    verbose\n) -> Bool\n\n\nCheck whether solution contains any conflicts between agents.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.is_individually_feasible-Tuple{Solution, MAPF}","page":"Internals","title":"MultiAgentPathFinding.is_individually_feasible","text":"is_individually_feasible(\n    solution::Solution,\n    mapf::MAPF;\n    verbose\n) -> Bool\n\n\nCheck whether solution is feasible when agents are considered separately.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.is_occupied_edge-Tuple{MultiAgentPathFinding.Reservation, Integer, Integer, Integer}","page":"Internals","title":"MultiAgentPathFinding.is_occupied_edge","text":"is_occupied_edge(\n    reservation::MultiAgentPathFinding.Reservation,\n    t::Integer,\n    u::Integer,\n    v::Integer\n) -> Bool\n\n\nCheck whether edge (u, v) is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.is_occupied_vertex-Tuple{MultiAgentPathFinding.Reservation, Integer, Integer}","page":"Internals","title":"MultiAgentPathFinding.is_occupied_vertex","text":"is_occupied_vertex(\n    reservation::MultiAgentPathFinding.Reservation,\n    t::Integer,\n    v::Integer\n) -> Any\n\n\nCheck whether vertex v is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.is_safe_vertex_to_stop-Tuple{MultiAgentPathFinding.Reservation, Integer, Integer}","page":"Internals","title":"MultiAgentPathFinding.is_safe_vertex_to_stop","text":"is_safe_vertex_to_stop(\n    reservation::MultiAgentPathFinding.Reservation,\n    t::Integer,\n    v::Integer\n) -> Union{Missing, Bool}\n\n\nCheck whether vertex v is safe to stop time t in a reservation, which means that no one else crosses it afterwards.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.occupy!-Tuple{MultiAgentPathFinding.Reservation, Integer, Integer, Integer}","page":"Internals","title":"MultiAgentPathFinding.occupy!","text":"occupy!(\n    reservation::MultiAgentPathFinding.Reservation,\n    a::Integer,\n    t::Integer,\n    v::Integer\n)\n\n\nUpdate reservation so that agent a occupies vertex v at time t.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.occupy!-Tuple{MultiAgentPathFinding.Reservation, Vararg{Integer, 4}}","page":"Internals","title":"MultiAgentPathFinding.occupy!","text":"occupy!(\n    reservation::MultiAgentPathFinding.Reservation,\n    a::Integer,\n    t::Integer,\n    u::Integer,\n    v::Integer\n)\n\n\nUpdate reservation so that agent a occupies edge (u, v) at time t.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.path_cost-Tuple{Vector{Int64}, SimpleWeightedGraphs.SimpleWeightedGraph}","page":"Internals","title":"MultiAgentPathFinding.path_cost","text":"path_cost(\n    path::Vector{Int64},\n    g::SimpleWeightedGraphs.SimpleWeightedGraph\n) -> Any\n\n\nSum the costs of all the edges in path within mapf.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.read_benchmark_scenario-Tuple{BenchmarkScenario}","page":"Internals","title":"MultiAgentPathFinding.read_benchmark_scenario","text":"read_benchmark_scenario(\n    scen::BenchmarkScenario\n) -> Vector{MultiAgentPathFinding.BenchmarkAgent}\n\n\nRead a scenario from an automatically downloaded text file.\n\nReturns a Vector{BenchmarkAgent}.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.read_benchmark_solution-Tuple{BenchmarkScenario}","page":"Internals","title":"MultiAgentPathFinding.read_benchmark_solution","text":"read_benchmark_solution(scen::BenchmarkScenario)\n\nRead a solution from an automatically downloaded text file.\n\nReturn a named tuple (; lower_cost, solution_cost, paths_coord_list) where:\n\nlower_cost is a (supposedly) proven lower bound on the optimal cost\nsolution_cost is the cost of the provided solution\npaths_coord_list is a vector of agent trajectories, each one being encoded as a vector of coordinate tuples (i, j) \n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiAgentPathFinding.update_reservation!-Tuple{MultiAgentPathFinding.Reservation, Vector{Int64}, Integer, MAPF}","page":"Internals","title":"MultiAgentPathFinding.update_reservation!","text":"update_reservation!(\n    reservation::MultiAgentPathFinding.Reservation,\n    path::Vector{Int64},\n    a::Integer,\n    mapf::MAPF\n)\n\n\nAdd the vertices and edges occupied by a path to a reservation.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Graphs\nusing MultiAgentPathFinding\nusing CairoMakie","category":"page"},{"location":"tutorial/#Instance-creation","page":"Tutorial","title":"Instance creation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A MAPF instance can be created from any undirected graph. Agents are specified by their departure and arrival vertex.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"graph = cycle_graph(10)\ndepartures = [1, 3]\narrivals = [4, 1]\nmapf = MAPF(graph, departures, arrivals)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, vertex and swapping conflicts are forbidden, and the agents stay at their arrival vertex. Another constructor is available that works with a grid and lists of coordinate tuples instead.","category":"page"},{"location":"tutorial/#Solution-algorithms","page":"Tutorial","title":"Solution algorithms","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can compute independent shortest paths with independent_dijkstra as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bad_solution = independent_dijkstra(mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The resulting object is a Solution, with one path per agent. As you can see from the output of is_feasible, this solution has a conflict:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is_feasible(bad_solution, mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To identify it, just call find_conflict:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"find_conflict(bad_solution, mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Prioritized planning with cooperative_astar helps you obtain a solution without conflict, at least when the instance is easy enough:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"good_solution = cooperative_astar(mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is_feasible(good_solution, mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can then evaluate its total path length with sum_of_costs:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sum_of_costs(good_solution, mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Of course that value depends on the agent ordering chosen for prioritized planning:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"better_solution = cooperative_astar(mapf, [2, 1])\nsum_of_costs(better_solution, mapf)","category":"page"},{"location":"tutorial/#Benchmark-dataset","page":"Tutorial","title":"Benchmark dataset","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To download and parse an instance from the standard MAPF benchmarks, just specify the name of its map and the details of its scenario inside a BenchmarkScenario:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"instance = \"Berlin_1_256\"\nscen_type = \"even\"\ntype_id = 1\nagents = 100\nscen = BenchmarkScenario(; instance, scen_type, type_id, agents)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then, the MAPF constructor will prompte you before downloading the necessary files:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bench_mapf = MAPF(scen; allow_diagonal_moves=true)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can visualize an instance with plot_mapf:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_mapf(scen; display_grid=false)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Best known solutions are also available for some instances thanks to the website Tracking Progress in MAPF. The Solution constructor will automatically download the necessary data:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"small_scen = BenchmarkScenario(; instance=\"empty-8-8\", scen_type=\"even\", type_id=1, agents=32)\nbenchmark_solution_best = Solution(small_scen)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nThe solution files for some instances can be very large (tens of GBs), so think before you validate the download.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For these grid instances, solutions can be visualized at any point in their time span, or recorded as an animation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_mapf(small_scen, benchmark_solution_best; video_path=joinpath(@__DIR__, \"solution.mp4\"))\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<video src=\"../solution.mp4\" width=\"700\" height=\"700\" controls></video>","category":"page"}]
}
