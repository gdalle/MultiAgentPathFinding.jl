var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Only exported names are part of the API.","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"MultiAgentPathFinding","category":"page"},{"location":"api/#MultiAgentPathFinding","page":"API reference","title":"MultiAgentPathFinding","text":"MultiAgentPathFinding\n\nA package for Multi-Agent Path Finding instances and algorithms.\n\nExports\n\nConflict\nMAPF\nSolution\nTimedPath\ncooperative_astar\ndouble_search\nfeasibility_search\nfind_conflict\nflowtime\nindependent_dijkstra\nis_feasible\nlist_map_names\nlist_scenario_names\nnb_agents\noptimality_search\nread_benchmark\nrepeated_cooperative_astar\nselect_agents\n\n\n\n\n\n","category":"module"},{"location":"api/#Structures","page":"API reference","title":"Structures","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"MAPF\nTimedPath\nSolution\nConflict","category":"page"},{"location":"api/#MultiAgentPathFinding.MAPF","page":"API reference","title":"MultiAgentPathFinding.MAPF","text":"struct MAPF{W<:Real, G<:Graphs.AbstractGraph{Int64}, M<:AbstractArray{W<:Real, 2}, VC, EC}\n\nInstance of a Multi-Agent Path Finding problem with custom conflict rules.\n\nAgents appear at their departure vertex when the departure time comes, and they disappear as soon as they have reached the arrival vertex.\n\nFields\n\ng::Graphs.AbstractGraph{Int64}: underlying graph\nedge_weights::AbstractMatrix{W} where W<:Real: matrix of edge weights\ndepartures::Vector{Int64}: agent departure vertices\narrivals::Vector{Int64}: agent arrival vertices\ndeparture_times::Vector{Int64}: agent departure times\nvertex_conflicts::Any: dict-like object linking vertices to their incompatibility set\nedge_conflicts::Any: dict-like object linking edges (as tuples) to their incompatibility set\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.TimedPath","page":"API reference","title":"MultiAgentPathFinding.TimedPath","text":"struct TimedPath\n\nTemporal path through a graph.\n\nFields\n\ntdep::Int64: departure time\npath::Vector{Int64}: sequence of vertices\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Solution","page":"API reference","title":"MultiAgentPathFinding.Solution","text":"Solution = Vector{TimedPath}\n\nVector of TimedPaths, one for each agent of a MAPF.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Conflict","page":"API reference","title":"MultiAgentPathFinding.Conflict","text":"struct Conflict\n\nStore a conflict between two agents for debugging purposes.\n\nFields\n\nname::Symbol: type of conflict (:vertex or :edge)\na1::Int64: first agent\na2::Int64: second agent\nt1::Int64: time for the first agent\nt2::Int64: time for the second agent\nu1::Int64: vertex for the first agent\nu2::Int64: vertex for the second agent\n\n\n\n\n\n","category":"type"},{"location":"api/#Access","page":"API reference","title":"Access","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"nb_agents\nselect_agents","category":"page"},{"location":"api/#MultiAgentPathFinding.nb_agents","page":"API reference","title":"MultiAgentPathFinding.nb_agents","text":"nb_agents(mapf)\n\nCount the number of agents.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.select_agents","page":"API reference","title":"MultiAgentPathFinding.select_agents","text":"select_agents(mapf, agents)\n\nSelect a subset of agents and return a new MAPF.\n\n\n\n\n\n","category":"function"},{"location":"api/#Feasibility-and-cost","page":"API reference","title":"Feasibility and cost","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"flowtime\nis_feasible\nfind_conflict","category":"page"},{"location":"api/#MultiAgentPathFinding.flowtime","page":"API reference","title":"MultiAgentPathFinding.flowtime","text":"flowtime(solution, mapf)\n\nSum the weight of all the paths in a solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.is_feasible","page":"API reference","title":"MultiAgentPathFinding.is_feasible","text":"is_feasible(solution, mapf[; verbose])\n\nCheck whether a solution is both individually and collectively feasible (correct paths and no conflicts).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.find_conflict","page":"API reference","title":"MultiAgentPathFinding.find_conflict","text":"find_conflict(solution, mapf[; tol=0])\n\nFind a conflict in a solution.\n\n\n\n\n\nfind_conflict(a1, a2, solution, mapf[; tol=0])\n\nFind a conflict between agents a1 and a2 in a solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#Basic-algorithms","page":"API reference","title":"Basic algorithms","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"independent_dijkstra\ncooperative_astar","category":"page"},{"location":"api/#MultiAgentPathFinding.independent_dijkstra","page":"API reference","title":"MultiAgentPathFinding.independent_dijkstra","text":"independent_dijkstra(mapf)\n\nCompute independent shortest paths for each agent.\n\nReturns a Solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.cooperative_astar","page":"API reference","title":"MultiAgentPathFinding.cooperative_astar","text":"cooperative_astar(mapf; ...)\ncooperative_astar(mapf, agents; show_progress)\n\n\nSolve a MAPF problem with the cooperative A* algorithm of Silver (2005), see https://ojs.aaai.org/index.php/AIIDE/article/view/18726.\n\nReturns a Solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#Local-search","page":"API reference","title":"Local search","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"repeated_cooperative_astar\nfeasibility_search\noptimality_search\ndouble_search","category":"page"},{"location":"api/#MultiAgentPathFinding.repeated_cooperative_astar","page":"API reference","title":"MultiAgentPathFinding.repeated_cooperative_astar","text":"repeated_cooperative_astar(\n    mapf;\n    coop_timeout,\n    show_progress\n)\n\n\nRepeat cooperative_astar with random permutations until a feasible solution is found or coop_timeout is reached.\n\nReturns a Solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.feasibility_search","page":"API reference","title":"MultiAgentPathFinding.feasibility_search","text":"feasibility_search(\n    mapf;\n    feasibility_timeout,\n    neighborhood_size,\n    conflict_price,\n    conflict_price_increase,\n    show_progress\n)\n\n\nRun independent_dijkstra and then reduce the number of conflicts with a variant of the MAPF-LNS2 algorithm from Li et al. (2022), see https://ojs.aaai.org/index.php/AAAI/article/view/21266.\n\nReturns a tuple containing a Solution and a dictionary of statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.optimality_search","page":"API reference","title":"MultiAgentPathFinding.optimality_search","text":"optimality_search(mapf; ...)\noptimality_search(\n    mapf,\n    agents;\n    optimality_timeout,\n    neighborhood_size,\n    show_progress\n)\n\n\nRun cooperative_astar and then reduce the solution flowtime with the MAPF-LNS algorithm from Li et al. (2021), see https://www.ijcai.org/proceedings/2021/568.\n\nReturns a tuple containing a Solution and a dictionary of statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.double_search","page":"API reference","title":"MultiAgentPathFinding.double_search","text":"double_search(mapf; ...)\ndouble_search(\n    mapf,\n    agents;\n    feasibility_timeout,\n    optimality_timeout,\n    neighborhood_size,\n    conflict_price,\n    conflict_price_increase,\n    show_progress\n)\n\n\nCombine feasibility_search and optimality_search, see https://pastel.hal.science/tel-04053322.\n\nReturns a tuple containing a Solution and a dictionary of statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#Benchmarks","page":"API reference","title":"Benchmarks","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"read_benchmark\nlist_map_names\nlist_scenario_names","category":"page"},{"location":"api/#MultiAgentPathFinding.read_benchmark","page":"API reference","title":"MultiAgentPathFinding.read_benchmark","text":"read_benchmark_mapf(map_name::AbstractString, scenario_name::AbstractString;)\n\nCreate a MAPF instance by reading a map (\"something.map\") and scenario (\"something.scen\") from files.\n\nSee possible names at https://movingai.com/benchmarks/mapf/index.html (data will be downloaded automatically).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.list_map_names","page":"API reference","title":"MultiAgentPathFinding.list_map_names","text":"list_map_names()\n\nList available maps from the benchmark set.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.list_scenario_names","page":"API reference","title":"MultiAgentPathFinding.list_scenario_names","text":"list_scenario_names()\n\nList available scenarios from the benchmark set.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MultiAgentPathFinding]\nPublic = false","category":"page"},{"location":"api/#MultiAgentPathFinding.LazyEdgeConflicts","page":"API reference","title":"MultiAgentPathFinding.LazyEdgeConflicts","text":"LazyEdgeConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(u, v)].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazySwappingConflicts","page":"API reference","title":"MultiAgentPathFinding.LazySwappingConflicts","text":"LazySwappingConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(v, u)].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazyVertexConflicts","page":"API reference","title":"MultiAgentPathFinding.LazyVertexConflicts","text":"LazyVertexConflicts\n\nLazy dict-like storage for the mapping v -> [v].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.MAPFBenchmarkProblem","page":"API reference","title":"MultiAgentPathFinding.MAPFBenchmarkProblem","text":"MAPFBenchmarkProblem\n\nEncode one agent of a MAPF scenario.\n\nFields\n\nindex::Int64\nbucket::Int64\nmap_path::String\nwidth::Int64\nheight::Int64\nstart_i::Int64\nstart_j::Int64\ngoal_i::Int64\ngoal_j::Int64\noptimal_length::Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Reservation","page":"API reference","title":"MultiAgentPathFinding.Reservation","text":"mutable struct Reservation\n\nStorage for vertices and edges that are known to be occupied.\n\nFields\n\nforbidden_vertices::Set{Tuple{Int64, Int64}}\nforbidden_edges::Set{Tuple{Int64, Int64, Int64}}\nmax_time::Int64: maximum time of all forbidden vertices (mutable)\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Reservation-Tuple{}","page":"API reference","title":"MultiAgentPathFinding.Reservation","text":"Reservation()\n\nCreate an empty reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.ShortestPathTree","page":"API reference","title":"MultiAgentPathFinding.ShortestPathTree","text":"struct ShortestPathTree{T, W}\n\nStorage for the result of Dijkstra's algorithm run backwards.\n\nFields\n\nchildren::Vector: successor of each vertex in a shortest path\ndists::Vector: distance of each vertex to the arrival\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.all_non_empty-Tuple{Vector{TimedPath}}","page":"API reference","title":"MultiAgentPathFinding.all_non_empty","text":"all_non_empty(solution)\n\nCheck that all paths in a solution are non empty.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.arrival_time-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.arrival_time","text":"arrival_time(timed_path)\n\nReturn the departure time of a timed path plus its number of edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.arrival_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.arrival_vertex","text":"arrival_vertex(timed_path)\n\nReturn the last vertex of a timed path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.backward_dijkstra-Union{Tuple{W}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, AbstractMatrix{W}}} where {T, W}","page":"API reference","title":"MultiAgentPathFinding.backward_dijkstra","text":"backward_dijkstra(g, w; arr)\n\nRun Dijkstra's algorithm backward from an arrival vertex, with specified edge weights.\n\nReturns a ShortestPathTree where distances can be nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.benchmark_cell_color-Tuple{Char}","page":"API reference","title":"MultiAgentPathFinding.benchmark_cell_color","text":"benchmark_cell_color(c::Char)\n\nGive a color object corresponding to the type of cell.\n\nTo visualize a map in VSCode, just run cell_color.(map_matrix) in the REPL.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_path_astar-Tuple{Dict, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.build_path_astar","text":"build_path_astar(parents, arr, tarr)\n\nBuild a TimedPath from a dictionary of temporal parents, going backward from arr which was reached at tarr.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_path_tree-Union{Tuple{T}, Tuple{MultiAgentPathFinding.ShortestPathTree{T}, Any, Any, Any}} where T","page":"API reference","title":"MultiAgentPathFinding.build_path_tree","text":"build_path_tree(spt, dep, arr, tdep)\n\nBuild a TimedPath from a ShortestPathTree, going from dep to arr and starting at time tdep.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.compute_reservation","page":"API reference","title":"MultiAgentPathFinding.compute_reservation","text":"compute_reservation(solution, mapf[; agents])\n\nCompute a Reservation based on the vertices and edges occupied by a solution (or a subset of its agents).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.count_conflicts-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_conflicts","text":"count_conflicts(a1, a2, solution, mapf[; tol=0])\n\nCount the number of conflicts between agents a1 and a2 in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_conflicts-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_conflicts","text":"count_conflicts(solution, mapf[; tol=0])\n\nCount the number of conflicts in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_edge_conflicts-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_edge_conflicts","text":"count_edge_conflicts(a1, a2, solution, mapf[; tol=0])\n\nCount the number of occurrences where the paths of a1 and a2 in the solution cross incompatible edges less than tol time steps apart.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_vertex_conflicts-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_vertex_conflicts","text":"count_vertex_conflicts(a1, a2, solution, mapf[; tol=0])\n\nCount the number of occurrences where the paths of a1 and a2 in the solution visit incompatible vertices less than tol time steps apart.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.departure_time-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.departure_time","text":"departure_time(timed_path)\n\nReturn the departure time of a timed path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.departure_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.departure_vertex","text":"departure_vertex(timed_path)\n\nReturn the first vertex of a timed path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.dijkstra_by_arrival-Union{Tuple{MAPF{W, G, M} where {G<:Graphs.AbstractGraph{Int64}, M<:AbstractMatrix{W}}}, Tuple{W}} where W","page":"API reference","title":"MultiAgentPathFinding.dijkstra_by_arrival","text":"dijkstra_by_arrival(mapf)\n\nRun backward_dijkstra from each arrival vertex of a MAPF.\n\nReturns a dictionary of ShortestPathTrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.edge_at_time-Tuple{TimedPath, Any}","page":"API reference","title":"MultiAgentPathFinding.edge_at_time","text":"edge_at_time(timed_path, t)\n\nReturn the edge crossed by a timed path at a given time, throws an error if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.empty_solution-Tuple{MAPF}","page":"API reference","title":"MultiAgentPathFinding.empty_solution","text":"empty_solution(mapf)\n\nReturn a vector of empty TimedPaths.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.exists_in_graph-Tuple{TimedPath, Graphs.AbstractGraph}","page":"API reference","title":"MultiAgentPathFinding.exists_in_graph","text":"exists_in_graph(timed_path, g)\n\nCheck that a timed path is feasible in the graph g, i.e. that all vertices and edges exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.find_edge_conflict-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.find_edge_conflict","text":"find_edge_conflict(a1, a2, solution, mapf[; tol=0])\n\nFind an occurrence where the paths of a1 and a2 in the solution cross incompatible edges less than tol time steps apart.\n\nReturns either a Conflict object or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.find_vertex_conflict-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.find_vertex_conflict","text":"find_vertex_conflict(a1, a2, solution, mapf[; tol=0])\n\nFind an occurrence where the paths of a1 and a2 in the solution visit incompatible vertices less than tol time steps apart.\n\nReturns either a Conflict object or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.independent_dijkstra_from_trees-Tuple{MAPF, Any}","page":"API reference","title":"MultiAgentPathFinding.independent_dijkstra_from_trees","text":"independent_dijkstra_from_trees(mapf, spt_by_arr)\n\nCompute independent shortest paths for each agent based on the output of dijkstra_by_arrival (i.e. a dictionary of ShortestPathTrees)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_collectively_feasible-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_collectively_feasible","text":"is_collectively_feasible(solution, mapf[; verbose])\n\nCheck whether a solution contains any conflicts between agents.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_forbidden_edge-Tuple{MultiAgentPathFinding.Reservation, Any, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.is_forbidden_edge","text":"is_forbidden_edge(reservation, t, u, v)\n\nCheck whether edge (u, v) is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_forbidden_vertex-Tuple{MultiAgentPathFinding.Reservation, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.is_forbidden_vertex","text":"is_forbidden_vertex(reservation, t, v)\n\nCheck whether vertex v is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_individually_feasible-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_individually_feasible","text":"is_individually_feasible(solution, mapf[; verbose])\n\nCheck whether a solution is feasible when agents are considered separately.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.makespan-Tuple{Vector{TimedPath}}","page":"API reference","title":"MultiAgentPathFinding.makespan","text":"makespan(solution)\n\nCompute the maximum arrival time of all the paths in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.max_time-Tuple{MultiAgentPathFinding.Reservation}","page":"API reference","title":"MultiAgentPathFinding.max_time","text":"max_time(reservation)\n\nReturn the maximum time of all forbidden vertices in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.parse_benchmark_map-Tuple{Matrix{Char}}","page":"API reference","title":"MultiAgentPathFinding.parse_benchmark_map","text":"parse_benchmark_map(map_matrix::Matrix{Char})\n\nCreate a sparse grid graph from a map specified as a matrix of characters.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.parse_benchmark_scenario-Tuple{Vector{MultiAgentPathFinding.MAPFBenchmarkProblem}, Dict}","page":"API reference","title":"MultiAgentPathFinding.parse_benchmark_scenario","text":"parse_benchmark_scenario(scenario::Vector{MAPFBenchmarkProblem}, coord_to_vertex::Dict)\n\nTurn a scenario into vectors of departure and arrival vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.path_length_tree-Tuple{MultiAgentPathFinding.ShortestPathTree, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.path_length_tree","text":"path_length_tree(spt, dep, arr)\n\nCount the edges in a shortest path from dep to arr based on a ShortestPathTree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.path_weight-Union{Tuple{W}, Tuple{TimedPath, MAPF{W, G, M} where {G<:Graphs.AbstractGraph{Int64}, M<:AbstractMatrix{W}}}} where W","page":"API reference","title":"MultiAgentPathFinding.path_weight","text":"path_weight(timed_path, mapf[; tmin, tmax])\n\nCompute the weight of a timed path through a MAPF graph by summing edge weights between times tmin and tmax (which default to the departure and arrival time).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.random_neighborhood-Tuple{MAPF, Any}","page":"API reference","title":"MultiAgentPathFinding.random_neighborhood","text":"random_neighborhood(mapf, neighborhood_size)\n\nReturn a random subset of agents with a given size.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.read_benchmark_map-Tuple{AbstractString}","page":"API reference","title":"MultiAgentPathFinding.read_benchmark_map","text":"read_benchmark_map(map_name::AbstractString)\n\nRead a map matrix from a text file.\n\nReturns a Matrix{Char}.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.read_benchmark_scenario-Tuple{AbstractString, AbstractString}","page":"API reference","title":"MultiAgentPathFinding.read_benchmark_scenario","text":"read_benchmark_scenario(scenario_name::AbstractString, map_name::AbstractString)\n\nRead a scenario from a text file, and check that it corresponds to a given map.\n\nReturns a Vector{MAPFBenchmarkProblem}.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.remove_agents!-Tuple{Vector{TimedPath}, Any, MAPF}","page":"API reference","title":"MultiAgentPathFinding.remove_agents!","text":"remove_agents!(solution, agents, mapf)\n\nRemove a set of agents from a solution and return a back up of their paths.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.remove_arrival_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.remove_arrival_vertex","text":"remove_arrival_vertex(timed_path)\n\nCut the last vertex from a timed path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar-Union{Tuple{W}, Tuple{V}, Tuple{Graphs.AbstractGraph{V}, AbstractMatrix{W}}} where {V, W}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar","text":"temporal_astar(g, w; dep, arr, tdep, tmax, res, heuristic)\n\nApply temporal A* to a graph with specified edge weights.\n\nKeyword arguments\n\ndep: departure vertex\narr: arrival vertex\ntdep: departure time\ntmax: max arrival time, after which the search stops and returns a partial path\nres: reservation indicating occupied vertices and edges at various times\nheuristic: indexable giving an underestimate of the remaining distance to arr\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar_soft-Union{Tuple{W}, Tuple{V}, Tuple{Graphs.AbstractGraph{V}, AbstractMatrix{W}}} where {V, W}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar_soft","text":"temporal_astar_soft(g, w; dep, arr, tdep, tmax, res, heuristic, conflict_price)\n\nApply a bi-objective variant of temporal A* to a graph with specified edge weights. The objective is to minimize a combination of the number of conflicts and the path weight.\n\nKeyword arguments\n\ndep, arr, tdep, tmax, res, heuristic: see temporal_astar.\nconflict_price: price given to the number of conflicts in the objective\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.update_reservation!-Tuple{MultiAgentPathFinding.Reservation, TimedPath, MAPF, Any}","page":"API reference","title":"MultiAgentPathFinding.update_reservation!","text":"update_reservation!(reservation, timed_path, mapf)\n\nAdd the vertices and edges occupied by a timed path to a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.vertex_at_time-Tuple{TimedPath, Any}","page":"API reference","title":"MultiAgentPathFinding.vertex_at_time","text":"vertex_at_time(timed_path, t)\n\nReturn the vertex visited by a timed path at a given time, throws an error if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"#MultiAgentPathFinding","page":"Home","title":"MultiAgentPathFinding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides a toolbox for defining and solving Multi-Agent PathFinding problems in the Julia programming language.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the latest stable version, open a Julia Pkg REPL and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MultiAgentPathFinding","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the development version, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gdalle/MultiAgentPathFinding.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"For now the documentation is a bit lacking, but take a look at the files in test for usage examples.","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiAgentPathFinding.jl contains some heuristic algorithms (cooperative A* and local search) described in the PhD thesis","category":"page"},{"location":"","page":"Home","title":"Home","text":"Machine learning and combinatorial optimization algorithms, with applications to railway planning, Dalle (2022)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It also contains a parser for the set of benchmark instances introduced by","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multi-Agent Pathfinding: Definitions, Variants, and Benchmarks, Stern et al. (2019)","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Alternative solvers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Shushman/MultiAgentPathFinding.jl: conflict-based search","category":"page"}]
}
