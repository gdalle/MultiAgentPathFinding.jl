var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Only exported names are part of the API.","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"MultiAgentPathFinding","category":"page"},{"location":"api/#MultiAgentPathFinding","page":"API reference","title":"MultiAgentPathFinding","text":"MultiAgentPathFinding\n\nA package for Multi-Agent Path Finding instances and algorithms.\n\nExports\n\nConflict\nMAPF\nSolution\nTimedPath\ncooperative_astar\ndouble_search\nfeasibility_search\nfind_conflict\nindependent_dijkstra\nis_feasible\nlist_map_names\nlist_scenario_names\nnb_agents\noptimality_search\npath_cost\nread_benchmark\nselect_agents\ntotal_path_cost\n\n\n\n\n\n","category":"module"},{"location":"api/#Structures","page":"API reference","title":"Structures","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"MAPF\nTimedPath\nSolution\nConflict","category":"page"},{"location":"api/#MultiAgentPathFinding.MAPF","page":"API reference","title":"MultiAgentPathFinding.MAPF","text":"struct MAPF{W<:Real, G<:Graphs.AbstractGraph{Int64}, M<:AbstractArray{W<:Real, 2}, VC, EC}\n\nInstance of a Multi-Agent Path Finding problem with custom conflict rules.\n\nAgents appear at their departure vertex when the departure time comes, and they disappear as soon as they have reached the arrival vertex.\n\nFields\n\ng::Graphs.AbstractGraph{Int64}: underlying graph\nedge_weights::AbstractMatrix{W} where W<:Real: matrix of edge weights\ndepartures::Vector{Int64}: agent departure vertices\narrivals::Vector{Int64}: agent arrival vertices\ndeparture_times::Vector{Int64}: agent departure times\nvertex_conflicts::Any: dict-like object linking vertices to their incompatibility set\nedge_conflicts::Any: dict-like object linking edges (as tuples) to their incompatibility set\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.TimedPath","page":"API reference","title":"MultiAgentPathFinding.TimedPath","text":"struct TimedPath\n\nTemporal path through a graph.\n\nFields\n\ntdep::Int64: departure time\npath::Vector{Int64}: sequence of vertices\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Solution","page":"API reference","title":"MultiAgentPathFinding.Solution","text":"Solution = Vector{TimedPath}\n\nVector of TimedPaths, one for each agent of a MAPF.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Conflict","page":"API reference","title":"MultiAgentPathFinding.Conflict","text":"struct Conflict\n\nStore a conflict between two agents for debugging purposes.\n\nFields\n\nname::Symbol: type of conflict (:vertex or :edge)\na1::Int64: first agent\na2::Int64: second agent\nt1::Int64: time for the first agent\nt2::Int64: time for the second agent\nu1::Int64: vertex for the first agent\nu2::Int64: vertex for the second agent\n\n\n\n\n\n","category":"type"},{"location":"api/#Access","page":"API reference","title":"Access","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"nb_agents\nselect_agents","category":"page"},{"location":"api/#MultiAgentPathFinding.nb_agents","page":"API reference","title":"MultiAgentPathFinding.nb_agents","text":"nb_agents(mapf::MAPF) -> Int64\n\n\nCount the number of agents.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.select_agents","page":"API reference","title":"MultiAgentPathFinding.select_agents","text":"select_agents(\n    mapf::MAPF,\n    agents::AbstractVector{<:Integer}\n) -> MAPF\n\n\nSelect a subset of agents and return a new MAPF.\n\n\n\n\n\n","category":"function"},{"location":"api/#Feasibility-and-cost","page":"API reference","title":"Feasibility and cost","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"path_cost\ntotal_path_cost\nis_feasible\nfind_conflict","category":"page"},{"location":"api/#MultiAgentPathFinding.path_cost","page":"API reference","title":"MultiAgentPathFinding.path_cost","text":"path_cost(\n    timed_path::TimedPath,\n    mapf::MAPF{W, G, M} where {G<:Graphs.AbstractGraph{Int64}, M<:AbstractArray{W, 2}};\n    tmin,\n    tmax\n) -> Any\n\n\nCompute the weight of a timed path by summing edge weights between times tmin and tmax (which default to the departure and arrival time).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.total_path_cost","page":"API reference","title":"MultiAgentPathFinding.total_path_cost","text":"total_path_cost(\n    solution::Vector{TimedPath},\n    mapf::MAPF\n) -> Any\n\n\nSum the weight of all the paths in a solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.is_feasible","page":"API reference","title":"MultiAgentPathFinding.is_feasible","text":"is_feasible(\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    verbose\n) -> Bool\n\n\nCheck whether a solution is both individually and collectively feasible (correct paths and no conflicts).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.find_conflict","page":"API reference","title":"MultiAgentPathFinding.find_conflict","text":"find_conflict(\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    tol\n) -> Union{Nothing, Conflict}\n\n\nFind a conflict in a solution.\n\n\n\n\n\nfind_conflict(\n    a1::Integer,\n    a2::Integer,\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    tol\n) -> Union{Nothing, Conflict}\n\n\nFind a conflict between agents a1 and a2 in a solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#Basic-algorithms","page":"API reference","title":"Basic algorithms","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"independent_dijkstra\ncooperative_astar","category":"page"},{"location":"api/#MultiAgentPathFinding.independent_dijkstra","page":"API reference","title":"MultiAgentPathFinding.independent_dijkstra","text":"independent_dijkstra(\n    mapf::MAPF;\n    show_progress\n) -> Vector{TimedPath}\n\n\nCompute independent shortest paths for each agent.\n\nReturns a Solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.cooperative_astar","page":"API reference","title":"MultiAgentPathFinding.cooperative_astar","text":"cooperative_astar(mapf::MAPF; ...) -> Vector\ncooperative_astar(\n    mapf::MAPF,\n    agents::AbstractVector{<:Integer};\n    show_progress\n) -> Vector\n\n\nSolve a MAPF problem with the cooperative A* algorithm of Silver (2005), see https://ojs.aaai.org/index.php/AIIDE/article/view/18726.\n\nReturns a Solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#Local-search","page":"API reference","title":"Local search","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"feasibility_search\noptimality_search\ndouble_search","category":"page"},{"location":"api/#MultiAgentPathFinding.feasibility_search","page":"API reference","title":"MultiAgentPathFinding.feasibility_search","text":"feasibility_search(\n    mapf::MAPF;\n    feasibility_timeout,\n    neighborhood_size,\n    conflict_price,\n    conflict_price_increase,\n    show_progress\n) -> Tuple{Vector{TimedPath}, Dict}\n\n\nRun independent_dijkstra and then reduce the number of conflicts with a variant of the MAPF-LNS2 algorithm from Li et al. (2022), see https://ojs.aaai.org/index.php/AAAI/article/view/21266.\n\nReturns a tuple containing a Solution and a dictionary of statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.optimality_search","page":"API reference","title":"MultiAgentPathFinding.optimality_search","text":"optimality_search(mapf::MAPF; ...) -> Tuple{Vector, Dict}\noptimality_search(\n    mapf::MAPF,\n    agents;\n    optimality_timeout,\n    neighborhood_size,\n    show_progress\n) -> Tuple{Vector, Dict}\n\n\nRun cooperative_astar and then reduce the total path cost with the MAPF-LNS algorithm from Li et al. (2021), see https://www.ijcai.org/proceedings/2021/568.\n\nReturns a tuple containing a Solution and a dictionary of statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.double_search","page":"API reference","title":"MultiAgentPathFinding.double_search","text":"double_search(mapf::MAPF; ...) -> Tuple{Vector, Dict}\ndouble_search(\n    mapf::MAPF,\n    agents;\n    feasibility_timeout,\n    optimality_timeout,\n    neighborhood_size,\n    conflict_price,\n    conflict_price_increase,\n    show_progress\n) -> Tuple{Vector, Dict}\n\n\nCombine feasibility_search and optimality_search, see https://pastel.hal.science/tel-04053322.\n\nReturns a tuple containing a Solution and a dictionary of statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#Benchmarks","page":"API reference","title":"Benchmarks","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"read_benchmark\nlist_map_names\nlist_scenario_names","category":"page"},{"location":"api/#MultiAgentPathFinding.read_benchmark","page":"API reference","title":"MultiAgentPathFinding.read_benchmark","text":"read_benchmark(\n    map_name::AbstractString,\n    scenario_name::AbstractString;\n    check\n) -> MAPF{Float64, SimpleWeightedGraphs.SimpleWeightedGraph{Int64, Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, MultiAgentPathFinding.LazyVertexConflicts, MultiAgentPathFinding.LazySwappingConflicts}\n\n\nCreate a MAPF instance by reading a map (\"something.map\") and scenario (\"something.scen\") from files.\n\nSee possible names at https://movingai.com/benchmarks/mapf/index.html (data will be downloaded automatically).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.list_map_names","page":"API reference","title":"MultiAgentPathFinding.list_map_names","text":"list_map_names() -> Vector{String}\n\n\nList available maps from the benchmark set.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.list_scenario_names","page":"API reference","title":"MultiAgentPathFinding.list_scenario_names","text":"list_scenario_names() -> Vector{String}\n\n\nList available scenarios from the benchmark set.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MultiAgentPathFinding]\nPublic = false","category":"page"},{"location":"api/#MultiAgentPathFinding.LazyEdgeConflicts","page":"API reference","title":"MultiAgentPathFinding.LazyEdgeConflicts","text":"struct LazyEdgeConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(u, v)].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazySwappingConflicts","page":"API reference","title":"MultiAgentPathFinding.LazySwappingConflicts","text":"struct LazySwappingConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(v, u)].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazyVertexConflicts","page":"API reference","title":"MultiAgentPathFinding.LazyVertexConflicts","text":"struct LazyVertexConflicts\n\nLazy dict-like storage for the mapping v -> [v].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.MAPFBenchmarkProblem","page":"API reference","title":"MultiAgentPathFinding.MAPFBenchmarkProblem","text":"struct MAPFBenchmarkProblem\n\nEncode one agent of a MAPF scenario.\n\nFields\n\nindex::Int64\nbucket::Int64\nmap_path::String\nwidth::Int64\nheight::Int64\nstart_i::Int64\nstart_j::Int64\ngoal_i::Int64\ngoal_j::Int64\noptimal_length::Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Reservation","page":"API reference","title":"MultiAgentPathFinding.Reservation","text":"mutable struct Reservation\n\nStorage for vertices and edges that are known to be occupied.\n\nFields\n\nforbidden_vertices::Set{Tuple{Int64, Int64}}\nforbidden_edges::Set{Tuple{Int64, Int64, Int64}}\nmax_time::Int64: maximum time of all forbidden vertices (mutable)\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Reservation-Tuple{}","page":"API reference","title":"MultiAgentPathFinding.Reservation","text":"Reservation() -> MultiAgentPathFinding.Reservation\n\n\nCreate an empty reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.ShortestPathTree","page":"API reference","title":"MultiAgentPathFinding.ShortestPathTree","text":"struct ShortestPathTree{T, W}\n\nStorage for the result of Dijkstra's algorithm run backwards.\n\nFields\n\nchildren::Vector: successor of each vertex in a shortest path\ndists::Vector: distance of each vertex to the arrival\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.all_non_empty-Tuple{Vector{TimedPath}}","page":"API reference","title":"MultiAgentPathFinding.all_non_empty","text":"all_non_empty(solution::Vector{TimedPath}) -> Bool\n\n\nCheck that all paths in a solution are non empty.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.arrival_time-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.arrival_time","text":"arrival_time(timed_path::TimedPath) -> Int64\n\n\nReturn the departure time of a timed path plus its number of edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.arrival_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.arrival_vertex","text":"arrival_vertex(timed_path::TimedPath) -> Int64\n\n\nReturn the last vertex of a timed path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.backward_dijkstra-Union{Tuple{W}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, AbstractMatrix{W}}} where {T, W}","page":"API reference","title":"MultiAgentPathFinding.backward_dijkstra","text":"backward_dijkstra(\n    g::Graphs.AbstractGraph{T},\n    w::AbstractArray{W, 2};\n    arr\n)\n\n\nRun Dijkstra's algorithm backward from an arrival vertex, with specified edge weights.\n\nReturns a ShortestPathTree where distances can be nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.benchmark_cell_color-Tuple{Char}","page":"API reference","title":"MultiAgentPathFinding.benchmark_cell_color","text":"benchmark_cell_color(\n    c::Char\n) -> ColorTypes.RGB{FixedPointNumbers.N0f8}\n\n\nGive a color object corresponding to the type of cell.\n\nTo visualize a map in VSCode, just run cell_color.(map_matrix) in the REPL.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_path_astar-Tuple{Dict, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.build_path_astar","text":"build_path_astar(\n    parents::Dict,\n    arr::Integer,\n    tarr::Integer\n) -> TimedPath\n\n\nBuild a TimedPath from a dictionary of temporal parents, going backward from arr which was reached at tarr.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_path_tree-Union{Tuple{T}, Tuple{MultiAgentPathFinding.ShortestPathTree{T}, Integer, Integer, Integer}} where T","page":"API reference","title":"MultiAgentPathFinding.build_path_tree","text":"build_path_tree(\n    spt::MultiAgentPathFinding.ShortestPathTree{T},\n    dep::Integer,\n    arr::Integer,\n    tdep::Integer\n) -> TimedPath\n\n\nBuild a TimedPath from a ShortestPathTree, going from dep to arr and starting at time tdep.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.compute_reservation","page":"API reference","title":"MultiAgentPathFinding.compute_reservation","text":"compute_reservation(\n    solution::Vector{TimedPath},\n    mapf::MAPF\n) -> MultiAgentPathFinding.Reservation\ncompute_reservation(\n    solution::Vector{TimedPath},\n    mapf::MAPF,\n    agents::AbstractVector{<:Integer}\n) -> MultiAgentPathFinding.Reservation\n\n\nCompute a Reservation based on the vertices and edges occupied by a solution (or a subset of its agents).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.count_conflicts-Tuple{Integer, Integer, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_conflicts","text":"count_conflicts(\n    a1::Integer,\n    a2::Integer,\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    tol\n) -> Any\n\n\nCount the number of conflicts between agents a1 and a2 in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_conflicts-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_conflicts","text":"count_conflicts(\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    tol\n) -> Any\n\n\nCount the number of conflicts in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_edge_conflicts-Tuple{Integer, Integer, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_edge_conflicts","text":"count_edge_conflicts(\n    a1::Integer,\n    a2::Integer,\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    tol\n) -> Any\n\n\nCount the number of occurrences where the paths of a1 and a2 in the solution cross incompatible edges less than tol time steps apart.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_vertex_conflicts-Tuple{Integer, Integer, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_vertex_conflicts","text":"count_vertex_conflicts(\n    a1::Integer,\n    a2::Integer,\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    tol\n) -> Any\n\n\nCount the number of occurrences where the paths of a1 and a2 in the solution visit incompatible vertices less than tol time steps apart.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.departure_time-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.departure_time","text":"departure_time(timed_path::TimedPath) -> Int64\n\n\nReturn the departure time of a timed path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.departure_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.departure_vertex","text":"departure_vertex(timed_path::TimedPath) -> Int64\n\n\nReturn the first vertex of a timed path.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.dijkstra_by_arrival-Union{Tuple{MAPF{W, G, M} where {G<:Graphs.AbstractGraph{Int64}, M<:AbstractMatrix{W}}}, Tuple{W}} where W","page":"API reference","title":"MultiAgentPathFinding.dijkstra_by_arrival","text":"dijkstra_by_arrival(\n    mapf::MAPF{W, G, M} where {G<:Graphs.AbstractGraph{Int64}, M<:AbstractArray{W, 2}};\n    show_progress\n) -> Dict{Int64, V} where V<:(MultiAgentPathFinding.ShortestPathTree{Int64})\n\n\nRun backward_dijkstra from each arrival vertex of a MAPF.\n\nReturns a dictionary of ShortestPathTrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.edge_at_time-Tuple{TimedPath, Integer}","page":"API reference","title":"MultiAgentPathFinding.edge_at_time","text":"edge_at_time(\n    timed_path::TimedPath,\n    t::Integer\n) -> Tuple{Any, Any}\n\n\nReturn the edge crossed by a timed path at a given time, throws an error if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.empty_solution-Tuple{MAPF}","page":"API reference","title":"MultiAgentPathFinding.empty_solution","text":"empty_solution(mapf::MAPF) -> Vector\n\n\nReturn a vector of empty TimedPaths.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.exists_in_graph-Tuple{TimedPath, Graphs.AbstractGraph}","page":"API reference","title":"MultiAgentPathFinding.exists_in_graph","text":"exists_in_graph(\n    timed_path::TimedPath,\n    g::Graphs.AbstractGraph\n) -> Bool\n\n\nCheck that a timed path is feasible in the graph g, i.e. that all vertices and edges exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.find_edge_conflict-Tuple{Integer, Integer, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.find_edge_conflict","text":"find_edge_conflict(\n    a1::Integer,\n    a2::Integer,\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    tol\n) -> Union{Nothing, Conflict}\n\n\nFind an occurrence where the paths of a1 and a2 in the solution cross incompatible edges less than tol time steps apart.\n\nReturns either a Conflict object or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.find_vertex_conflict-Tuple{Integer, Integer, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.find_vertex_conflict","text":"find_vertex_conflict(\n    a1::Integer,\n    a2::Integer,\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    tol\n) -> Union{Nothing, Conflict}\n\n\nFind an occurrence where the paths of a1 and a2 in the solution visit incompatible vertices less than tol time steps apart.\n\nReturns either a Conflict object or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.independent_dijkstra_from_trees-Tuple{MAPF, Dict{<:Integer, <:MultiAgentPathFinding.ShortestPathTree}}","page":"API reference","title":"MultiAgentPathFinding.independent_dijkstra_from_trees","text":"independent_dijkstra_from_trees(\n    mapf::MAPF,\n    spt_by_arr::Dict{<:Integer, <:MultiAgentPathFinding.ShortestPathTree}\n) -> Vector{TimedPath}\n\n\nCompute independent shortest paths for each agent based on the output of dijkstra_by_arrival (i.e. a dictionary of ShortestPathTrees)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_collectively_feasible-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_collectively_feasible","text":"is_collectively_feasible(\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    verbose\n) -> Bool\n\n\nCheck whether a solution contains any conflicts between agents.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_forbidden_edge-Tuple{MultiAgentPathFinding.Reservation, Integer, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.is_forbidden_edge","text":"is_forbidden_edge(\n    reservation::MultiAgentPathFinding.Reservation,\n    t::Integer,\n    u::Integer,\n    v::Integer\n) -> Bool\n\n\nCheck whether edge (u, v) is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_forbidden_vertex-Tuple{MultiAgentPathFinding.Reservation, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.is_forbidden_vertex","text":"is_forbidden_vertex(\n    reservation::MultiAgentPathFinding.Reservation,\n    t::Integer,\n    v::Integer\n) -> Bool\n\n\nCheck whether vertex v is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_individually_feasible-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_individually_feasible","text":"is_individually_feasible(\n    solution::Vector{TimedPath},\n    mapf::MAPF;\n    verbose\n) -> Bool\n\n\nCheck whether a solution is feasible when agents are considered separately.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.makespan-Tuple{Vector{TimedPath}}","page":"API reference","title":"MultiAgentPathFinding.makespan","text":"makespan(solution::Vector{TimedPath}) -> Int64\n\n\nCompute the maximum arrival time of all the paths in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.map_from_scenario-Tuple{AbstractString}","page":"API reference","title":"MultiAgentPathFinding.map_from_scenario","text":"map_from_scenario(scenario_name::AbstractString) -> String\n\n\nReturn the map associated with a benchmark scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.max_time-Tuple{MultiAgentPathFinding.Reservation}","page":"API reference","title":"MultiAgentPathFinding.max_time","text":"max_time(\n    reservation::MultiAgentPathFinding.Reservation\n) -> Int64\n\n\nReturn the maximum time of all forbidden vertices in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.parse_benchmark_map-Tuple{Matrix{Char}}","page":"API reference","title":"MultiAgentPathFinding.parse_benchmark_map","text":"parse_benchmark_map(\n    map_matrix::Matrix{Char}\n) -> Tuple{SimpleWeightedGraphs.SimpleWeightedGraph{Int64, Float64}, Dict{Tuple{Int64, Int64}, Int64}}\n\n\nCreate a sparse grid graph from a map specified as a matrix of characters.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.parse_benchmark_scenario-Tuple{Vector{MultiAgentPathFinding.MAPFBenchmarkProblem}, Dict}","page":"API reference","title":"MultiAgentPathFinding.parse_benchmark_scenario","text":"parse_benchmark_scenario(\n    scenario::Vector{MultiAgentPathFinding.MAPFBenchmarkProblem},\n    coord_to_vertex::Dict\n) -> Tuple{Vector{Int64}, Vector{Int64}}\n\n\nTurn a scenario into vectors of departure and arrival vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.path_length_tree-Tuple{MultiAgentPathFinding.ShortestPathTree, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.path_length_tree","text":"path_length_tree(\n    spt::MultiAgentPathFinding.ShortestPathTree,\n    dep::Integer,\n    arr::Integer\n) -> Int64\n\n\nCount the edges in a shortest path from dep to arr based on a ShortestPathTree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.random_neighborhood-Tuple{MAPF, Integer}","page":"API reference","title":"MultiAgentPathFinding.random_neighborhood","text":"random_neighborhood(\n    mapf::MAPF,\n    neighborhood_size::Integer\n) -> AbstractArray\n\n\nReturn a random subset of agents with a given size.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.read_benchmark_map-Tuple{AbstractString}","page":"API reference","title":"MultiAgentPathFinding.read_benchmark_map","text":"read_benchmark_map(map_name::AbstractString) -> Matrix{Char}\n\n\nRead a map matrix from a text file.\n\nReturns a Matrix{Char}.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.read_benchmark_scenario-Tuple{AbstractString, AbstractString}","page":"API reference","title":"MultiAgentPathFinding.read_benchmark_scenario","text":"read_benchmark_scenario(\n    scenario_name::AbstractString,\n    map_name::AbstractString\n) -> Vector{MultiAgentPathFinding.MAPFBenchmarkProblem}\n\n\nRead a scenario from a text file, and check that it corresponds to a given map.\n\nReturns a Vector{MAPFBenchmarkProblem}.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.remove_agents!-Tuple{Vector{TimedPath}, AbstractVector{<:Integer}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.remove_agents!","text":"remove_agents!(\n    solution::Vector{TimedPath},\n    agents::AbstractVector{<:Integer},\n    mapf::MAPF\n) -> Dict\n\n\nRemove a set of agents from a solution and return a back up of their paths.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.scenarios_from_map-Tuple{AbstractString}","page":"API reference","title":"MultiAgentPathFinding.scenarios_from_map","text":"scenarios_from_map(\n    map_name::AbstractString\n) -> Vector{String}\n\n\nList the scenarios associated with a benchmark map.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar-Union{Tuple{W}, Tuple{V}, Tuple{Graphs.AbstractGraph{V}, AbstractMatrix{W}}} where {V, W}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar","text":"temporal_astar(\n    g::Graphs.AbstractGraph{V},\n    w::AbstractArray{W, 2};\n    dep,\n    arr,\n    tdep,\n    res,\n    heuristic\n)\n\n\nApply temporal A* to a graph with specified edge weights.\n\nKeyword arguments\n\ndep: departure vertex\narr: arrival vertex\ntdep: departure time\nres: reservation indicating occupied vertices and edges at various times\nheuristic: indexable giving an underestimate of the remaining distance to arr\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar_soft-Union{Tuple{W}, Tuple{V}, Tuple{Graphs.AbstractGraph{V}, AbstractMatrix{W}}} where {V, W}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar_soft","text":"temporal_astar_soft(\n    g::Graphs.AbstractGraph{V},\n    w::AbstractArray{W, 2};\n    dep,\n    arr,\n    tdep,\n    res,\n    heuristic,\n    conflict_price\n)\n\n\nApply a bi-objective variant of temporal A* to a graph with specified edge weights. The objective is to minimize a combination of the number of conflicts and the path weight.\n\nKeyword arguments\n\ndep, arr, tdep, res, heuristic: see temporal_astar.\nconflict_price: price given to the number of conflicts in the objective\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.update_reservation!-Tuple{MultiAgentPathFinding.Reservation, TimedPath, MAPF}","page":"API reference","title":"MultiAgentPathFinding.update_reservation!","text":"update_reservation!(\n    reservation::MultiAgentPathFinding.Reservation,\n    timed_path::TimedPath,\n    mapf::MAPF\n)\n\n\nAdd the vertices and edges occupied by a timed path to a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.vertex_at_time-Tuple{TimedPath, Integer}","page":"API reference","title":"MultiAgentPathFinding.vertex_at_time","text":"vertex_at_time(timed_path::TimedPath, t::Integer) -> Any\n\n\nReturn the vertex visited by a timed path at a given time, throws an error if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"#MultiAgentPathFinding","page":"Home","title":"MultiAgentPathFinding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides a toolbox for defining and solving Multi-Agent PathFinding problems in the Julia programming language.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the latest stable version, open a Julia Pkg REPL and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MultiAgentPathFinding","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the development version, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gdalle/MultiAgentPathFinding.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"For now the documentation is a bit lacking, but take a look at the files in test for usage examples.","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiAgentPathFinding.jl contains some heuristic algorithms (cooperative A* and local search) described in the PhD thesis","category":"page"},{"location":"","page":"Home","title":"Home","text":"Machine learning and combinatorial optimization algorithms, with applications to railway planning, Dalle (2022)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It also contains a parser for the set of benchmark instances introduced by","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multi-Agent Pathfinding: Definitions, Variants, and Benchmarks, Stern et al. (2019)","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Alternative solvers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Shushman/MultiAgentPathFinding.jl: conflict-based search","category":"page"}]
}
