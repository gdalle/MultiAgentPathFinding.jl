var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Docs","page":"API reference","title":"Docs","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MultiAgentPathFinding]","category":"page"},{"location":"api/#MultiAgentPathFinding.MultiAgentPathFinding","page":"API reference","title":"MultiAgentPathFinding.MultiAgentPathFinding","text":"MultiAgentPathFinding\n\nA package for Multi-Agent Path Finding instances and algorithms.\n\n\n\n\n\n","category":"module"},{"location":"api/#MultiAgentPathFinding.Conflict","page":"API reference","title":"MultiAgentPathFinding.Conflict","text":"Conflict\n\nStore a conflict between two agents for debugging purposes.\n\nFields\n\nname::String: type of conflict (\"Vertex\" or \"Edge\")\na1::Int: first agent\na2::Int: second agent\nt1::Int: time for the first agent\nt2::Int: time for the second agent\nu1::Int: vertex for the first agent\nu2::Int: vertex for the second agent\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazyEdgeConflicts","page":"API reference","title":"MultiAgentPathFinding.LazyEdgeConflicts","text":"LazyEdgeConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(u, v)].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazySwappingConflicts","page":"API reference","title":"MultiAgentPathFinding.LazySwappingConflicts","text":"LazySwappingConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(v, u)].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazyVertexConflicts","page":"API reference","title":"MultiAgentPathFinding.LazyVertexConflicts","text":"LazyVertexConflicts\n\nLazy dict-like storage for the mapping v -> [v].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.MAPF","page":"API reference","title":"MultiAgentPathFinding.MAPF","text":"MAPF{W,G,VC,EC}\n\nInstance of a Multi-Agent Path Finding problem with custom conflict rules.\n\nFields\n\ng::G: underlying graph\ndepartures::Vector{Int}: agent departure vertices\narrivals::Vector{Int}: agent arrival vertices\ndeparture_times::Vector{Int}: agent departure times\nvertex_conflicts::VC: dict-like object linking vertices to their incompatibility set\nedge_conflicts::EC: dict-like object linking edges to their incompatibility set\nedge_indices::Dict{Tuple{Int,Int},Int}: dict linking edges to their rank in edges(g)\nedge_colptr::Vector{Int}: used for construction of sparse adjacency matrix\nedge_rowval::Vector{Int}: used for construction of sparse adjacency matrix\nedge_weights_vec::Vector{W}: edge weights flattened according to their rank in edges(g)\nflexible_departure::Bool: whether departure can happen after the prescribed departure time\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.MAPF-Tuple{G} where G","page":"API reference","title":"MultiAgentPathFinding.MAPF","text":"MAPF(g; departures, arrivals[, departure_times, vertex_conflicts, edge_conflicts])\n\nUser-friendly constructor for a Multi-Agent Path Finding problem.\n\nDeparture times default to 1 for every agent, vertex conflicts default to LazyVertexConflicts and edge conflicts to LazySwappingConflicts.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.Reservation","page":"API reference","title":"MultiAgentPathFinding.Reservation","text":"Reservation\n\nStorage for vertices and edges that are known to be occupied.\n\nFields\n\nforbidden_vertices::Set{Tuple{Int,Int}}: set of tuples (t, v)\nforbidden_edges::Set{Tuple{Int,Int,Int}}: set of tuples (t, u, v)\nmax_time::Int: maximum time of all forbidden vertices (mutable)\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Reservation-Tuple{}","page":"API reference","title":"MultiAgentPathFinding.Reservation","text":"Reservation()\n\nCreate an empty Reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.ShortestPathTree","page":"API reference","title":"MultiAgentPathFinding.ShortestPathTree","text":"ShortestPathTree{T,W}\n\nStorage for the result of Dijkstra's algorithm.\n\nFields\n\nforward::Bool: whether Dijkstra was run from the departure or the arrival\nparents::Vector{T}: predecessor of each vertex in a shortest path\ndists::Vector{W}: distance of each vertex to the arrival (if forward = true) or from the departure (if forward = false)\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Solution","page":"API reference","title":"MultiAgentPathFinding.Solution","text":"Solution = Vector{TimedPath}\n\nVector of TimedPaths, one for each agent of a MAPF.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.TimedPath","page":"API reference","title":"MultiAgentPathFinding.TimedPath","text":"TimedPath\n\nTemporal path through a graph.\n\nFields\n\ntdep::Int: departure time\npath::Vector{Int}: sequence of vertices\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.TimedPath-Tuple{Any}","page":"API reference","title":"MultiAgentPathFinding.TimedPath","text":"TimedPath(tdep)\n\nReturn an empty TimedPath.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.all_non_empty-Tuple{Vector{TimedPath}}","page":"API reference","title":"MultiAgentPathFinding.all_non_empty","text":"all_non_empty(solution)\n\nCheck that all paths in a Solution are non empty.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.arrival_time-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.arrival_time","text":"arrival_time(timed_path)\n\nReturn the departure time of a TimedPath plus its number of edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.arrival_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.arrival_vertex","text":"arrival_vertex(timed_path)\n\nReturn the last vertex of a TimedPath.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.backward_dijkstra-Union{Tuple{W}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, Any, AbstractMatrix{W}}} where {T, W}","page":"API reference","title":"MultiAgentPathFinding.backward_dijkstra","text":"backward_dijkstra(g, arr, w)\n\nRun Dijkstra's algorithm backward from an arrival vertex, with specified edge weights. Return a ShortestPathTree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_edge_data-Tuple{Graphs.AbstractGraph}","page":"API reference","title":"MultiAgentPathFinding.build_edge_data","text":"build_edge_data(g::AbstractGraph)\n\nPrecompute edge indices dictionary and useful data for construction of sparse adjacency matrix (see build_weights_matrix).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_path_astar-Tuple{Dict, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.build_path_astar","text":"build_path_astar(parents, arr, tarr)\n\nBuild a TimedPath from a dictionary of temporal parents, going backward from arr which was reached at tarr.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_path_tree-Union{Tuple{T}, Tuple{MultiAgentPathFinding.ShortestPathTree{T}, Any, Any, Any}} where T","page":"API reference","title":"MultiAgentPathFinding.build_path_tree","text":"build_path_tree(spt, dep, arr, tdep)\n\nBuild a TimedPath from a ShortestPathTree, going from dep to arr and starting at time tdep.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_weights_matrix","page":"API reference","title":"MultiAgentPathFinding.build_weights_matrix","text":"build_weights_matrix(mapf[, edge_weights_vec])\n\nTurn a vector edge_weights_vec into a sparse adjacency matrix for the graph mapf.g.\n\nThis function doesn't allocate because the necessary index information is already available in a MAPF object.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.compute_reservation","page":"API reference","title":"MultiAgentPathFinding.compute_reservation","text":"compute_reservation(solution, mapf[; agents])\n\nCompute a Reservation based on the vertices and edges occupied by solution (or a subset of its agents).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.concat_paths-Tuple{TimedPath, TimedPath}","page":"API reference","title":"MultiAgentPathFinding.concat_paths","text":"concat_path(timed_path1, timed_path2)\n\nConcatenate two compatible TimedPaths.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.cooperative_astar","page":"API reference","title":"MultiAgentPathFinding.cooperative_astar","text":"cooperative_astar(solution, mapf, agents, edge_weights_vec, spt_by_arr)\n\nCreate an empty Solution, a dictionary of ShortestPathTrees and apply cooperative_astar_from_trees!.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.cooperative_astar_from_trees!-Union{Tuple{W}, Tuple{G}, Tuple{Vector{TimedPath}, MAPF{G}, Any, AbstractVector{W}, Any}} where {G, W}","page":"API reference","title":"MultiAgentPathFinding.cooperative_astar_from_trees!","text":"cooperative_astar_from_trees!(solution, mapf, agents, edge_weights_vec, spt_by_arr)\n\nModify a Solution by applying temporal_astar to a subset of agents while avoiding conflicts thanks to a Reservation.\n\nArguments\n\nagents: subset of agents taken in order\nedge_weights_vec: edge weights stored as a vector\nspt_by_arr: dictionary of ShortestPathTrees, one for each arrival vertex\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.cooperative_astar_soft_from_trees!-Union{Tuple{W}, Tuple{Vector{TimedPath}, MAPF, Any, AbstractVector{W}, Any}} where W","page":"API reference","title":"MultiAgentPathFinding.cooperative_astar_soft_from_trees!","text":"cooperative_astar_from_trees_soft!(solution, mapf, agents, edge_weights_vec, spt_by_arr)\n\nDoes the same things as cooperative_astar_from_trees! but with temporal_astar_soft as a basic subroutine.\n\nArguments\n\nagents, edge_weights, spt_by_arr: see cooperative_astar_from_trees!\nconflict_price: see temporal_astar_soft\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_conflicts-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_conflicts","text":"count_conflicts(a1, a2, solution, mapf[; tol=0])\n\nCount the number of conflicts between agents a1 and a2 in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_conflicts-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_conflicts","text":"count_conflicts(solution, mapf[; tol=0])\n\nCount the number of conflicts in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_edge_conflicts-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_edge_conflicts","text":"count_edge_conflicts(a1, a2, solution, mapf[; tol=0])\n\nCount the number of occurrences where the paths of a1 and a2 in the solution cross incompatible edges less than tol time steps apart.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.count_vertex_conflicts-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.count_vertex_conflicts","text":"count_vertex_conflicts(a1, a2, solution, mapf[; tol=0])\n\nCount the number of occurrences where the paths of a1 and a2 in the solution visit incompatible vertices less than tol time steps apart.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.departure_time-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.departure_time","text":"departure_time(timed_path)\n\nReturn the departure time of a TimedPath.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.departure_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.departure_vertex","text":"departure_vertex(timed_path)\n\nReturn the first vertex of a TimedPath.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.dijkstra_by_arrival-Union{Tuple{W}, Tuple{MAPF, AbstractVector{W}}} where W","page":"API reference","title":"MultiAgentPathFinding.dijkstra_by_arrival","text":"dijkstra_by_arrival(mapf, edge_weights_vec)\n\nRun backward_dijkstra from each arrival vertex of a MAPF and return a dictionary of ShortestPathTrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.double_search","page":"API reference","title":"MultiAgentPathFinding.double_search","text":"double_search(\n    mapf, agents, edge_weights_vec;\n    feasibility_timeout, optimality_timeout, window,\n    neighborhood_size, conflict_price, conflict_price_increase\n)\n\nInitialize a Solution with independent_dijkstra, then apply [feasibility_search!] to make it feasible, followed by optimality_search! to reduce its flowtime.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.edge_at_time-Tuple{TimedPath, Any}","page":"API reference","title":"MultiAgentPathFinding.edge_at_time","text":"edge_at_time(timed_path, t)\n\nReturn the edge crossed by a TimedPath at a given time, throws an error if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.empty_solution-Tuple{MAPF}","page":"API reference","title":"MultiAgentPathFinding.empty_solution","text":"empty_solution(mapf)\n\nReturn a vector of empty TimedPaths.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.exists_in_graph-Tuple{TimedPath, Graphs.AbstractGraph}","page":"API reference","title":"MultiAgentPathFinding.exists_in_graph","text":"exists_in_graph(timed_path, g)\n\nCheck that a TimedPath is feasible in the graph g, i.e. that all vertices and edges exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.feasibility_search","page":"API reference","title":"MultiAgentPathFinding.feasibility_search","text":"feasibility_search(\n    mapf, edge_weights_vec;\n    feasibility_timeout, neighborhood_size, conflict_price, conflict_price_increase\n)\n\nInitialize a Solution with independent_dijkstra, and then apply feasibility_search! to reduce the number of conflicts.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.feasibility_search!-Tuple{Vector{TimedPath}, MAPF, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.feasibility_search!","text":"feasibility_search!(\n    solution, mapf, edge_weights_vec, spt_by_arr;\n    feasibility_timeout, neighborhood_size, conflict_price, conflict_price_increase\n)\n\nReduce the number of conflicts in an infeasible Solution with a variant of the MAPF-LNS2 algorithm from Li et al. (2022).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.find_conflict-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.find_conflict","text":"find_conflict(a1, a2, solution, mapf[; tol=0])\n\nFind a conflict between agents a1 and a2 in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.find_conflict-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.find_conflict","text":"find_conflict(solution, mapf[; tol=0])\n\nFind a conflict in a solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.find_edge_conflict-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.find_edge_conflict","text":"find_edge_conflict(a1, a2, solution, mapf[; tol=0])\n\nFind an occurrence where the paths of a1 and a2 in the solution cross incompatible edges less than tol time steps apart.\n\nReturn either a Conflict object or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.find_vertex_conflict-Tuple{Any, Any, Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.find_vertex_conflict","text":"find_vertex_conflict(a1, a2, solution, mapf[; tol=0])\n\nFind an occurrence where the paths of a1 and a2 in the solution visit incompatible vertices less than tol time steps apart.\n\nReturn either a Conflict object or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.flowtime","page":"API reference","title":"MultiAgentPathFinding.flowtime","text":"flowtime(solution, mapf[, edge_weights_vec])\n\nSum the flowtime of all the TimedPaths in a Solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.flowtime-Union{Tuple{W}, Tuple{TimedPath, MAPF}, Tuple{TimedPath, MAPF, AbstractVector{W}}} where W","page":"API reference","title":"MultiAgentPathFinding.flowtime","text":"flowtime(timed_path, mapf[, edge_weights_vec])\n\nCompute the weight of a TimedPath through a MAPF graph from its departure_time until its standstill_time.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.forward_dijkstra-Union{Tuple{W}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, Any, AbstractMatrix{W}}} where {T, W}","page":"API reference","title":"MultiAgentPathFinding.forward_dijkstra","text":"forward_dijkstra(g, dep, w)\n\nRun Dijkstra's algorithm forward from a departure vertex, with specified edge weights. Return a ShortestPathTree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.independent_dijkstra","page":"API reference","title":"MultiAgentPathFinding.independent_dijkstra","text":"independent_dijkstra(mapf[, edge_weight_vec])\n\nCompute independent shortest paths for each agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.independent_dijkstra_from_trees-Tuple{MAPF, Any}","page":"API reference","title":"MultiAgentPathFinding.independent_dijkstra_from_trees","text":"independent_dijkstra_from_trees(mapf, spt_by_arr)\n\nCompute independent shortest paths for each agent based on the output of dijkstra_by_arrival (i.e. a dictionary of ShortestPathTrees)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_collectively_feasible-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_collectively_feasible","text":"is_collectively_feasible(solution, mapf[; verbose])\n\nCheck whether a Solution contains any conflicts between agents.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_feasible-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_feasible","text":"is_feasible(solution, mapf[; verbose])\n\nCheck whether a Solution is both individually and collectively feasible.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_forbidden_edge-Tuple{Reservation, Any, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.is_forbidden_edge","text":"is_forbidden_edge(reservation, t, u, v)\n\nCheck whether edge (u, v) is occupied at time t in a Reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_forbidden_vertex-Tuple{Reservation, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.is_forbidden_vertex","text":"is_forbidden_vertex(reservation, t, v)\n\nCheck whether vertex v is occupied at time t in a Reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_individually_feasible-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_individually_feasible","text":"is_individually_feasible(solution, mapf[; verbose])\n\nCheck whether a Solution is feasible when agents are considered separately.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.makespan-Tuple{Vector{TimedPath}}","page":"API reference","title":"MultiAgentPathFinding.makespan","text":"makespan(solution)\n\nCompute the maximum arrival time of all the TimedPaths in a Solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.max_time-Tuple{Reservation}","page":"API reference","title":"MultiAgentPathFinding.max_time","text":"max_time(reservation)\n\nReturn the maximum time of all forbidden vertices in a Reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.nb_agents-Tuple{MAPF}","page":"API reference","title":"MultiAgentPathFinding.nb_agents","text":"nb_agents(mapf)\n\nCount the number of agents.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.optimality_search","page":"API reference","title":"MultiAgentPathFinding.optimality_search","text":"optimality_search(\n    mapf, agents, edge_weights_vec, spt_by_arr;\n    optimality_timeout, neighborhood_size\n)\n\nInitialize a Solution with cooperative_astar, and then apply optimality_search! to reduce its flowtime.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.optimality_search!-Tuple{Vector{TimedPath}, MAPF, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.optimality_search!","text":"optimality_search!(\n    solution, mapf, edge_weights_vec, spt_by_arr;\n    optimality_timeout, neighborhood_size\n)\n\nReduce the flowtime of a feasible Solution with the MAPF-LNS algorithm from Li et al. (2021).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.path_length_tree-Tuple{MultiAgentPathFinding.ShortestPathTree, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.path_length_tree","text":"path_length_tree(spt, dep, arr)\n\nCount the edges in a shortest path from dep to arr based on a ShortestPathTree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.path_weight-Union{Tuple{W}, Tuple{TimedPath, MAPF}, Tuple{TimedPath, MAPF, AbstractVector{W}}} where W","page":"API reference","title":"MultiAgentPathFinding.path_weight","text":"path_weight(timed_path, mapf, [edge_weights_vec; tmin, tmax])\n\nCompute the weight of a TimedPath through a MAPF graph by summing edge weights between times tmin and tmax (which default to the departure_time and arrival_time).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.random_neighborhood-Tuple{MAPF, Any}","page":"API reference","title":"MultiAgentPathFinding.random_neighborhood","text":"random_neighborhood(mapf, neighborhood_size)\n\nReturn a random subset of agents with a given size.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.remove_agents!-Tuple{Vector{TimedPath}, Any, MAPF}","page":"API reference","title":"MultiAgentPathFinding.remove_agents!","text":"remove_agents!(solution, agents, mapf)\n\nRemove a set of agents from a Solution and return a back up of their paths.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.remove_arrival_vertex-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.remove_arrival_vertex","text":"remove_arrival_vertex(timed_path)\n\nCut the last vertex from a TimedPath.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.repeated_cooperative_astar","page":"API reference","title":"MultiAgentPathFinding.repeated_cooperative_astar","text":"repeated_cooperative_astar(mapf, edge_weights_vec; coop_timeout)\n\nCompute a dictionary of ShortestPathTrees with dijkstra_by_arrival, and then apply repeated_cooperative_astar_from_trees.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.repeated_cooperative_astar_from_trees-Tuple{MAPF, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.repeated_cooperative_astar_from_trees","text":"repeated_cooperative_astar_from_trees(mapf, edge_weights_vec, spt_by_arr; coop_timeout)\n\nApply cooperative_astar_from_trees! repeatedly until a feasible solution is found or the timeout given by coop_timeout is reached.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.replace_agents-Tuple{MAPF, Any, Any, Any}","page":"API reference","title":"MultiAgentPathFinding.replace_agents","text":"replace_agents(mapf, new_departures, new_arrivals, new_departure_times)\n\nReturn a new MAPF with fresh agent data.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.select_agents-Tuple{MAPF, Any}","page":"API reference","title":"MultiAgentPathFinding.select_agents","text":"select_agents(mapf, agents)\n\nSelect a subset of agents and return a new MAPF.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.select_agents-Tuple{MAPF, Integer}","page":"API reference","title":"MultiAgentPathFinding.select_agents","text":"select_agents(mapf, nb_agents)\n\nSelect the first nb_agents and return a new MAPF.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.standstill_time-Tuple{TimedPath}","page":"API reference","title":"MultiAgentPathFinding.standstill_time","text":"standstill_time(timed_path)\n\nCompute the time at which a TimedPath stops moving (which may be earlier than its arrival time if it stays motionless at the end).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar-Union{Tuple{W}, Tuple{V}, Tuple{Graphs.AbstractGraph{V}, AbstractMatrix{W}}} where {V, W}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar","text":"temporal_astar(g, w; dep, arr, tdep, tmax, res, heuristic)\n\nApply temporal A* to a graph with specified edge weights. Subroutine of cooperative_astar_from_trees! and optimality_search!.\n\nKeyword arguments\n\ndep: departure vertex\narr: arrival vertex\ntdep: departure time\ntmax: max arrival time, after which the search stops and returns a partial path\nres: reservation indicating occupied vertices and edges at various times\nheuristic: callable giving an underestimate of the remaining distance to arr\nflexible_departure: whether departure can occur after tdep\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar_soft-Union{Tuple{W}, Tuple{V}, Tuple{Graphs.AbstractGraph{V}, AbstractMatrix{W}}} where {V, W}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar_soft","text":"temporal_astar_soft(g, w; dep, arr, tdep, tmax, res, heuristic, conflict_price)\n\nApply a bi-objective variant of temporal A* to a graph with specified edge weights. The objective is to minimize a combination of the number of conflicts and the path weight. Subroutine of feasibility_search!.\n\nKeyword arguments\n\ndep, arr, tdep, tmax, res, heuristic, flexible_departure: see temporal_astar.\nconflict_price: price given to the number of conflicts in the objective\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.update_reservation!-Tuple{Reservation, TimedPath, MAPF, Any}","page":"API reference","title":"MultiAgentPathFinding.update_reservation!","text":"update_reservation!(reservation, timed_path, mapf)\n\nAdd the vertices and edges occupied by a path to a Reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.vertex_at_time-Tuple{TimedPath, Any}","page":"API reference","title":"MultiAgentPathFinding.vertex_at_time","text":"vertex_at_time(timed_path, t)\n\nReturn the vertex visited by a TimedPath at a given time, throws an error if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiAgentPathFinding","category":"page"},{"location":"#MultiAgentPathFinding.jl","page":"Home","title":"MultiAgentPathFinding.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements several heuristic solvers for Multi-Agent PathFinding[1] in the Julia programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Multi-Agent Pathfinding: Definitions, Variants, and Benchmarks, Stern et al. (2019)","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation is simple: just open a Julia Pkg REPL and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gdalle/MultiAgentPathFinding.jl","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Packages using MultiAgentPathFinding.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"gdalle/MAPFBenchmarks.jl: application to standard grid benchmarks\ngdalle/Flatland.jl: application to the Flatland challenge","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternative solvers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Shushman/MultiAgentPathFinding.jl","category":"page"}]
}
