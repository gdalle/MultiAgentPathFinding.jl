var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Types","page":"API reference","title":"Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MultiAgentPathFinding]\nPages = [\n    \"structs/mapf.jl\",\n    \"structs/path.jl\",\n    \"structs/reservation.jl\",\n    \"structs/solution.jl\"\n]","category":"page"},{"location":"api/#MultiAgentPathFinding.MAPF","page":"API reference","title":"MultiAgentPathFinding.MAPF","text":"MAPF{G}\n\nInstance of a Multi-Agent PathFinding problem with custom conflict rules.\n\nFields\n\ng::G\nedge_indices::Dict{Tuple{Int,Int},Int}\nedge_colptr::Vector{Int}\nedge_rowval::Vector{Int}\nedge_weights_vec::Vector{Float64}\nvertex_conflicts::Vector{Vector{Int}}\nedge_conflicts::Vector{Vector{Int}}\nsources::Vector{Int}\ndestinations::Vector{Int}\nstarting_times::Vector{Int}\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.build_weights_matrix","page":"API reference","title":"MultiAgentPathFinding.build_weights_matrix","text":"build_edge_weights_matrix(mapf[, edge_weights_vec])\n\nTurn a vector edge_weights_vec into a sparse weighted adjacency matrix for the graph mapf.g.\n\nThis function doesn't allocate because the necessary index information is already in the MAPF object.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.nb_agents-Tuple{MAPF}","page":"API reference","title":"MultiAgentPathFinding.nb_agents","text":"nb_agents(mapf)\n\nCount the number of agents in mapf.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.TimedPath","page":"API reference","title":"MultiAgentPathFinding.TimedPath","text":"TimedPath\n\nTemporal path through a graph.\n\nFields\n\nt0::Int\npath::Vector{Int}\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.path_to_vec-Tuple{TimedPath, MAPF}","page":"API reference","title":"MultiAgentPathFinding.path_to_vec","text":"path_to_vec(timed_path, mapf)\n\nEncode a timed_path as a dense integer vector that counts edge crossings.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.path_to_vec_sparse-Tuple{TimedPath, MAPF}","page":"API reference","title":"MultiAgentPathFinding.path_to_vec_sparse","text":"path_to_vec_sparse(timed_path, mapf)\n\nEncode a timed_path as a sparse integer vector that counts edge crossings.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.Reservation","page":"API reference","title":"MultiAgentPathFinding.Reservation","text":"Reservation\n\nStorage for vertices and edges that are already occupied.\n\nFields\n\nforbidden_vertices::Set{Tuple{Int,Int}}: set of tuples (t,v)\nforbidden_edges::Set{Tuple{Int,Int}}: set of tuples (t,e)\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.compute_reservation-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.compute_reservation","text":"compute_reservation(solution, mapf; [agents])\n\nCompute a Reservation based on the vertices and edges occupied by solution (or a subset of its agents).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_forbidden_edge-Tuple{Reservation, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.is_forbidden_edge","text":"is_forbidden_edge(reservation, t, e)\n\nCheck whether edge e is occupied at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_forbidden_vertex-Tuple{Reservation, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.is_forbidden_vertex","text":"is_forbidden_vertex(reservation, t, v)\n\nCheck whether vertex v is occupied at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.update_reservation!-Tuple{Reservation, TimedPath, MAPF}","page":"API reference","title":"MultiAgentPathFinding.update_reservation!","text":"update_reservation!(reservation, timed_path, mapf)\n\nAdd the vertices and edges occupied by timed_path to reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.Solution","page":"API reference","title":"MultiAgentPathFinding.Solution","text":"Solution = Vector{TimedPath}\n\nVector of TimedPaths, one for each agent of a MAPF.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.remove_agents!-Tuple{Vector{TimedPath}, Any, MAPF}","page":"API reference","title":"MultiAgentPathFinding.remove_agents!","text":"remove_agents!(solution, agents, mapf)\n\nRemove a set of agents from a solution and return a back up of their paths.\n\n\n\n\n\n","category":"method"},{"location":"api/#Shortest-paths","page":"API reference","title":"Shortest paths","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MultiAgentPathFinding]\nPages = [\n    \"paths/bellman_ford.jl\",\n    \"paths/cooperative_astar.jl\",\n    \"paths/dijkstra.jl\",\n    \"paths/independent_dijkstra.jl\",\n    \"paths/temporal_astar.jl\",\n]","category":"page"},{"location":"api/#MultiAgentPathFinding.ShortestPathTree","page":"API reference","title":"MultiAgentPathFinding.ShortestPathTree","text":"ShortestPathTree{T,W}\n\nStorage for the result of Dijkstra's algorithm.\n\nFields\n\nforward::Bool\nparents::Vector{T}\ndists::Vector{W}\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.backward_dijkstra-Union{Tuple{W}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, Integer, AbstractMatrix{W}}} where {T<:Integer, W<:AbstractFloat}","page":"API reference","title":"MultiAgentPathFinding.backward_dijkstra","text":"backward_dijkstra(g, d, w)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_dijkstra_path-Tuple{MultiAgentPathFinding.ShortestPathTree, Integer, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.build_dijkstra_path","text":"build_dijkstra_path(shortest_path_tree, t0, s, d)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.forward_dijkstra-Union{Tuple{W}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, Integer, AbstractMatrix{W}}} where {T<:Integer, W<:AbstractFloat}","page":"API reference","title":"MultiAgentPathFinding.forward_dijkstra","text":"forward_dijkstra(g, s, w)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.build_astar_path-Tuple{Dict, Integer, Integer, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.build_astar_path","text":"build_astar_path(parents, t0, s, tf, d)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar-Union{Tuple{W}, Tuple{V}, Tuple{Graphs.AbstractGraph{V}, Integer, Integer, Integer, AbstractMatrix{W}}, Tuple{Graphs.AbstractGraph{V}, Integer, Integer, Integer, AbstractMatrix{W}, Reservation}} where {V, W<:AbstractFloat}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar","text":"temporal_astar(g, s, d, t0, w[, reservation; heuristic, conflict_price])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar_hard-Union{Tuple{W}, Tuple{V}, Tuple{Graphs.AbstractGraph{V}, Integer, Integer, Integer, AbstractMatrix{W}}, Tuple{Graphs.AbstractGraph{V}, Integer, Integer, Integer, AbstractMatrix{W}, Reservation}} where {V, W}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar_hard","text":"temporal_astar_hard(g, s, d, t0, w[, reservation; heuristic])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.temporal_astar_soft-Union{Tuple{W}, Tuple{V}, Tuple{Graphs.AbstractGraph{V}, Integer, Integer, Integer, AbstractMatrix{W}}, Tuple{Graphs.AbstractGraph{V}, Integer, Integer, Integer, AbstractMatrix{W}, Reservation}} where {V, W}","page":"API reference","title":"MultiAgentPathFinding.temporal_astar_soft","text":"temporal_astar_soft(g, s, d, t0, w[, reservation; heuristic, conflict_price])\n\n\n\n\n\n","category":"method"},{"location":"api/#Local-search","page":"API reference","title":"Local search","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MultiAgentPathFinding]\nPages = [\n    \"local_search/feasibility_search.jl\",\n    \"local_search/large_neighborhood_search.jl\",\n    \"local_search/neighborhood.jl\",\n]","category":"page"},{"location":"api/#Solution-evaluation","page":"API reference","title":"Solution evaluation","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MultiAgentPathFinding]\nPages = [\n    \"eval/conflicts.jl\",\n    \"eval/cost.jl\",\n    \"eval/feasibility.jl\",\n]","category":"page"},{"location":"api/#MultiAgentPathFinding.flowtime","page":"API reference","title":"MultiAgentPathFinding.flowtime","text":"flowtime(solution, mapf[, edge_weights_vec])\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.max_time-Tuple{Vector{TimedPath}}","page":"API reference","title":"MultiAgentPathFinding.max_time","text":"max_time(solution)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.path_weight-Union{Tuple{W}, Tuple{TimedPath, MAPF}, Tuple{TimedPath, MAPF, AbstractVector{W}}} where W","page":"API reference","title":"MultiAgentPathFinding.path_weight","text":"path_weight(timed_path, mapf[, edge_weights_vec])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.has_empty_paths-Tuple{Vector{TimedPath}}","page":"API reference","title":"MultiAgentPathFinding.has_empty_paths","text":"has_empty_paths(solution)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_feasible-Tuple{Vector{TimedPath}, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_feasible","text":"is_feasible(solution)\n\n\n\n\n\n","category":"method"},{"location":"api/#Embedding","page":"API reference","title":"Embedding","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [MultiAgentPathFinding]\nPages = [\n    \"embedding/features_agents.jl\",\n    \"embedding/features_edges.jl\",\n    \"embedding/features_both.jl\",\n    \"embedding/embedding.jl\",\n]","category":"page"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiAgentPathFinding","category":"page"},{"location":"#MultiAgentPathFinding.jl","page":"Home","title":"MultiAgentPathFinding.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements several heuristic solvers for Multi-Agent PathFinding[1] in the Julia programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Multi-Agent Pathfinding: Definitions, Variants, and Benchmarks, Stern et al. (2019)","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation is simple: just open a Julia Pkg REPL and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gdalle/MultiAgentPathFinding.jl","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Packages using MultiAgentPathFinding.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"gdalle/MAPFBenchmarks.jl: application to standard grid benchmarks\ngdalle/Flatland.jl: application to the Flatland challenge","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternative solvers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Shushman/MultiAgentPathFinding.jl","category":"page"}]
}
