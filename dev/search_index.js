var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Only exported names are part of the API.","category":"page"},{"location":"api/#MultiAgentPathFinding","page":"API reference","title":"MultiAgentPathFinding","text":"MultiAgentPathFinding\n\nA package for Multi-Agent Path Finding instances and algorithms.\n\nExports\n\nEdgeConflict\nMAPF\nReservation\nSolution\nVertexConflict\ncooperative_astar\nfind_conflict\nindependent_dijkstra\nis_feasible\nlist_map_names\nlist_scenario_names\nnb_agents\npath_cost\nselect_agents\nsum_of_costs\n\n\n\n\n\n","category":"module"},{"location":"api/#Structures","page":"API reference","title":"Structures","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.MAPF","page":"API reference","title":"MultiAgentPathFinding.MAPF","text":"struct MAPF{W, VC, EC}\n\nInstance of a Multi-Agent Path Finding problem with custom conflict rules.\n\nConstructors\n\nMAPF(\n    g::AbstractGraph, departures::Vector{Int}, arrivals::Vector{Int};\n    vertex_conflicts=LazyVertexConflicts(), edge_conflicts=LazyEdgeConflicts()\n)\n\nFields\n\ng::SimpleWeightedGraphs.SimpleWeightedGraph{Int64, W} where W: underlying weighted graph\ndepartures::Vector{Int64}: agent departure vertices\narrivals::Vector{Int64}: agent arrival vertices\nvertex_conflicts::Any: indexable object linking vertices to their incompatibility set\nedge_conflicts::Any: indexable object linking edges (as tuples) to their incompatibility set\nvertex_to_coord::Union{Missing, Vector{Tuple{Int64, Int64}}}: mapping from integer vertices to coordinate tuples\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Solution","page":"API reference","title":"MultiAgentPathFinding.Solution","text":"struct Solution\n\nStore one path for each agent of a MAPF.\n\nFields\n\npaths::Vector{Vector{Int64}}\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.Reservation","page":"API reference","title":"MultiAgentPathFinding.Reservation","text":"struct Reservation\n\nKeep track of which vertices and edges are known to be occupied and by whom.\n\nIt does not have to be a physical occupation: some agent might be occupying a related vertex or edge which generates a conflict.\n\nFields\n\nsingle_occupied_vertices::Dict{Tuple{Int64, Int64}, Int64}: (t, v) -> a where a is the only agent occupying v at time t\nsingle_occupied_edges::Dict{Tuple{Int64, Int64, Int64}, Int64}: (t, u, v) -> a where a is the only agent occupying (u, v) at time t\nmulti_occupied_vertices::Dict{Tuple{Int64, Int64}, Vector{Int64}}: (t, v) -> [a1, a2] where a1, a2 are the multiple agents occupying v at time t\nmulti_occupied_edges::Dict{Tuple{Int64, Int64, Int64}, Vector{Int64}}: (t, u, v) -> [a1, a2] where a1, a2 are the multiple agents occupying (u, v) at time t\narrival_vertices::Dict{Int64, Tuple{Int64, Int64}}: v -> (t, a) where a is the agent whose arrival vertex is v and who owns it starting at time t (necessary for stay-at-target behavior)\narrival_vertices_crossings::Dict{Int64, Vector{Tuple{Int64, Int64}}}: v -> [(t2, a1), (t2, a2)] where the ai are additional agents visiting vertex v at times ti, once it is already owned as an arrival vertex\n\nNote\n\nThe split between single and multi is done for efficiency reasons: there will be many more single_occupied than multi_occupied, so allocating a set for all of these would be wasteful (and using Union{Int, Set{Int}} would be type-unstable).\n\n\n\n\n\n","category":"type"},{"location":"api/#Access","page":"API reference","title":"Access","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.nb_agents","page":"API reference","title":"MultiAgentPathFinding.nb_agents","text":"nb_agents(mapf::MAPF) -> Int64\n\n\nCount the number of agents in mapf.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.select_agents","page":"API reference","title":"MultiAgentPathFinding.select_agents","text":"select_agents(\n    mapf::MAPF,\n    agents::AbstractVector{<:Integer}\n) -> MAPF\n\n\nSelect a subset of agents in mapf and return a new MAPF.\n\n\n\n\n\n","category":"function"},{"location":"api/#Feasibility-and-cost","page":"API reference","title":"Feasibility and cost","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.path_cost","page":"API reference","title":"MultiAgentPathFinding.path_cost","text":"path_cost(\n    path::Vector{Int64},\n    g::SimpleWeightedGraphs.SimpleWeightedGraph\n) -> Any\n\n\nSum the costs of all the edges in path within mapf.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.sum_of_costs","page":"API reference","title":"MultiAgentPathFinding.sum_of_costs","text":"sum_of_costs(solution::Solution, mapf::MAPF) -> Any\n\n\nSum the costs of all the paths in solution. Costs are computed within mapf for each agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.is_feasible","page":"API reference","title":"MultiAgentPathFinding.is_feasible","text":"is_feasible(solution::Solution, mapf::MAPF; verbose) -> Bool\n\n\nCheck whether solution is both individually and collectively feasible (correct paths and no conflicts).\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.find_conflict","page":"API reference","title":"MultiAgentPathFinding.find_conflict","text":"find_conflict(\n    solution::Solution,\n    mapf::MAPF\n) -> Union{Nothing, EdgeConflict, VertexConflict}\n\n\nFind a conflict in solution for mapf.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.VertexConflict","page":"API reference","title":"MultiAgentPathFinding.VertexConflict","text":"struct VertexConflict\n\nTemporal vertex conflict between two agents (for debugging purposes).\n\nFields\n\nt::Int64: time\nv::Int64: vertex\na1::Int64: first agent\na2::Int64: second agent\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.EdgeConflict","page":"API reference","title":"MultiAgentPathFinding.EdgeConflict","text":"struct EdgeConflict\n\nTemporal edge conflict between two agents (for debugging purposes).\n\nFields\n\nt::Int64: time\nu::Int64: edge source\nv::Int64: edge destination\na1::Int64: first agent\na2::Int64: second agent\n\n\n\n\n\n","category":"type"},{"location":"api/#Basic-algorithms","page":"API reference","title":"Basic algorithms","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.independent_dijkstra","page":"API reference","title":"MultiAgentPathFinding.independent_dijkstra","text":"independent_dijkstra(mapf::MAPF) -> Solution\n\n\nCompute independent shortest paths for each agent of mapf.\n\nReturns a Solution where some paths may be empty if the vertices are not connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.cooperative_astar","page":"API reference","title":"MultiAgentPathFinding.cooperative_astar","text":"cooperative_astar(mapf::MAPF) -> Solution\ncooperative_astar(\n    mapf::MAPF,\n    agents::AbstractVector{<:Integer}\n) -> Solution\n\n\nSolve a MAPF problem mapf for a set of agents with the cooperative A* algorithm of Silver (2005), see https://ojs.aaai.org/index.php/AIIDE/article/view/18726.\n\nReturns a Solution where some paths may be empty if the vertices are not connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Benchmarks","page":"API reference","title":"Benchmarks","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.list_map_names","page":"API reference","title":"MultiAgentPathFinding.list_map_names","text":"list_map_names() -> Vector{String}\n\n\nList available maps from the benchmark set.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiAgentPathFinding.list_scenario_names","page":"API reference","title":"MultiAgentPathFinding.list_scenario_names","text":"list_scenario_names(scen_type::String) -> Vector{String}\n\n\nList available scenarios from the benchmark set.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api/#MultiAgentPathFinding.LazySwappingConflicts","page":"API reference","title":"MultiAgentPathFinding.LazySwappingConflicts","text":"struct LazySwappingConflicts\n\nLazy dict-like storage for the mapping (u, v) -> [(v, u)].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.LazyVertexConflicts","page":"API reference","title":"MultiAgentPathFinding.LazyVertexConflicts","text":"struct LazyVertexConflicts\n\nLazy dict-like storage for the mapping v -> [v].\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.MAPFBenchmarkAgent","page":"API reference","title":"MultiAgentPathFinding.MAPFBenchmarkAgent","text":"struct MAPFBenchmarkAgent\n\nEncode one agent of a MAPF scenario.\n\nFields\n\nindex::Int64\nbucket::Int64\nmap_path::String\nwidth::Int64\nheight::Int64\nstart_i::Int64\nstart_j::Int64\ngoal_i::Int64\ngoal_j::Int64\noptimal_length::Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiAgentPathFinding.arrive!-Tuple{Reservation, Integer, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.arrive!","text":"arrive!(\n    reservation::Reservation,\n    a::Integer,\n    t::Integer,\n    v::Integer\n)\n\n\nUpdate reservation so that agent a arrives vertex v at time t and never moves again.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.cell_color-Tuple{Char}","page":"API reference","title":"MultiAgentPathFinding.cell_color","text":"cell_color(\n    c::Char\n) -> ColorTypes.RGB{FixedPointNumbers.N0f8}\n\n\nGive a color object corresponding to the type of cell.\n\nTo visualize a map in VSCode, just run cell_color.(map_matrix) in the REPL.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.exists_in_graph-Tuple{Vector{Int64}, SimpleWeightedGraphs.SimpleWeightedGraph}","page":"API reference","title":"MultiAgentPathFinding.exists_in_graph","text":"exists_in_graph(\n    path::Vector{Int64},\n    g::SimpleWeightedGraphs.SimpleWeightedGraph\n) -> Bool\n\n\nCheck that path is feasible in the graph g, i.e. that all vertices and edges exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_collectively_feasible-Tuple{Solution, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_collectively_feasible","text":"is_collectively_feasible(\n    solution::Solution,\n    mapf::MAPF;\n    verbose\n) -> Bool\n\n\nCheck whether solution contains any conflicts between agents.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_individually_feasible-Tuple{Solution, MAPF}","page":"API reference","title":"MultiAgentPathFinding.is_individually_feasible","text":"is_individually_feasible(\n    solution::Solution,\n    mapf::MAPF;\n    verbose\n) -> Bool\n\n\nCheck whether solution is feasible when agents are considered separately.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_occupied_edge-Tuple{Reservation, Integer, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.is_occupied_edge","text":"is_occupied_edge(\n    reservation::Reservation,\n    t::Integer,\n    u::Integer,\n    v::Integer\n) -> Bool\n\n\nCheck whether edge (u, v) is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.is_occupied_vertex-Tuple{Reservation, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.is_occupied_vertex","text":"is_occupied_vertex(\n    reservation::Reservation,\n    t::Integer,\n    v::Integer\n) -> Any\n\n\nCheck whether vertex v is occupied at time t in a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.map_from_scenario-Tuple{AbstractString}","page":"API reference","title":"MultiAgentPathFinding.map_from_scenario","text":"map_from_scenario(scenario_name::AbstractString) -> String\n\n\nReturn the map associated with a benchmark scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.occupy!-Tuple{Reservation, Integer, Integer, Integer}","page":"API reference","title":"MultiAgentPathFinding.occupy!","text":"occupy!(\n    reservation::Reservation,\n    a::Integer,\n    t::Integer,\n    v::Integer\n)\n\n\nUpdate reservation so that agent a occupies vertex v at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.occupy!-Tuple{Reservation, Vararg{Integer, 4}}","page":"API reference","title":"MultiAgentPathFinding.occupy!","text":"occupy!(\n    reservation::Reservation,\n    a::Integer,\n    t::Integer,\n    u::Integer,\n    v::Integer\n)\n\n\nUpdate reservation so that agent a occupies edge (u, v) at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.parse_benchmark_map-Tuple{AbstractMatrix}","page":"API reference","title":"MultiAgentPathFinding.parse_benchmark_map","text":"parse_benchmark_map(\n    map_matrix::AbstractMatrix\n) -> Tuple{SimpleWeightedGraphs.SimpleWeightedGraph{Int64, Float64}, Dict{Tuple{Int64, Int64}, Int64}, Vector{Tuple{Int64, Int64}}}\n\n\nCreate a sparse grid graph from a map specified as a matrix of characters.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.parse_benchmark_scenario-Tuple{Vector{MultiAgentPathFinding.MAPFBenchmarkAgent}}","page":"API reference","title":"MultiAgentPathFinding.parse_benchmark_scenario","text":"parse_benchmark_scenario(\n    scenario::Vector{MultiAgentPathFinding.MAPFBenchmarkAgent}\n) -> Tuple{Vector{Tuple{Int64, Int64}}, Vector{Tuple{Int64, Int64}}}\n\n\nTurn a scenario into vectors of departure coordinates and a vector of arrival coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.read_benchmark_map-Tuple{AbstractString}","page":"API reference","title":"MultiAgentPathFinding.read_benchmark_map","text":"read_benchmark_map(map_name::AbstractString) -> Matrix{Char}\n\n\nRead a map matrix from a text file.\n\nReturns a Matrix{Char}.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.read_benchmark_scenario-Tuple{AbstractString, AbstractString}","page":"API reference","title":"MultiAgentPathFinding.read_benchmark_scenario","text":"read_benchmark_scenario(\n    scenario_name::AbstractString,\n    map_name::AbstractString\n) -> Vector{MultiAgentPathFinding.MAPFBenchmarkAgent}\n\n\nRead a scenario from a text file, and check that it corresponds to a given map.\n\nReturns a Vector{MAPFBenchmarkAgent}.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.scenarios_from_map-Tuple{AbstractString, String}","page":"API reference","title":"MultiAgentPathFinding.scenarios_from_map","text":"scenarios_from_map(\n    map_name::AbstractString,\n    scen_type::String\n) -> Vector{String}\n\n\nList the scenarios associated with a benchmark map.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiAgentPathFinding.update_reservation!-Tuple{Reservation, Vector{Int64}, Integer, MAPF}","page":"API reference","title":"MultiAgentPathFinding.update_reservation!","text":"update_reservation!(\n    reservation::Reservation,\n    path::Vector{Int64},\n    a::Integer,\n    mapf::MAPF\n)\n\n\nAdd the vertices and edges occupied by a path to a reservation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"#MultiAgentPathFinding","page":"Home","title":"MultiAgentPathFinding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides a toolbox for defining and solving multi-agent pathfinding problems in the Julia programming language.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the latest stable version, open a Julia Pkg REPL and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MultiAgentPathFinding","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the development version, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gdalle/MultiAgentPathFinding.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"For now the documentation is a bit lacking, but take a look at the files in test for usage examples.","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiAgentPathFinding.jl contains basic optimization algorithms related to multi-agent pathfinding, as well as a parser for the standard benchmark instances described in","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multi-Agent Pathfinding: Definitions, Variants, and Benchmarks, Stern et al. (2019)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use this package, please cite the following PhD dissertation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Machine learning and combinatorial optimization algorithms, with applications to railway planning, Dalle (2022)","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Alternative solvers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Shushman/MultiAgentPathFinding.jl: conflict-based search","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Graphs\nusing MultiAgentPathFinding","category":"page"},{"location":"tutorial/#Instance-creation","page":"Tutorial","title":"Instance creation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A MAPF instance can be created from any undirected graph. Agents are specified by their departure and arrival vertex.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"g = cycle_graph(10)\ndepartures = [1, 3]\narrivals = [4, 1]\nmapf = MAPF(g, departures, arrivals)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, vertex and swapping conflicts are forbidden, and the agents stay at their arrival vertex.","category":"page"},{"location":"tutorial/#Solution-algorithms","page":"Tutorial","title":"Solution algorithms","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can compute independent shortest paths with independent_dijkstra as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bad_solution = independent_dijkstra(mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The resulting object is a Solution, with one path per agent. As you can see, this solution has a conflict:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is_feasible(bad_solution, mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"find_conflict(bad_solution, mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Prioritized planning with cooperative_astar helps you obtain a solution without conflict:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"good_solution = cooperative_astar(mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is_feasible(good_solution, mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can then evaluate its total path length:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sum_of_costs(good_solution, mapf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Of course that value depends on the agent ordering chosen for prioritized planning:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"better_solution = cooperative_astar(mapf, [2, 1])\nsum_of_costs(better_solution, mapf)","category":"page"},{"location":"tutorial/#Benchmark-dataset","page":"Tutorial","title":"Benchmark dataset","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To download and parse an instance from the standard MAPF benchmarks, just specify the name of its map and scenario files:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"map_name = \"Berlin_1_256.map\"\nscenario_name = \"Berlin_1_256-even-1.scen\"\nbench_mapf = MAPF(map_name, scenario_name)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can visualize it as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MultiAgentPathFinding: read_benchmark_map, cell_color\n\ncell_color.(read_benchmark_map(map_name))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If the instance is too big, a subset of agents can be taken:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"select_agents(bench_mapf, 1:100)","category":"page"}]
}
